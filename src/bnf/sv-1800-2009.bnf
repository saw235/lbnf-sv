-- A.1 Source Text (Done)
-- A.1.1 Library Source Text (Done)
rules LibraryText ::= [LibraryDescription];

rules LibraryDescription ::= LibraryDeclaration | IncludeStatement 
                            | ConfigDeclaration | ";";

rules LibraryDeclaration ::= 
"library" LibraryIdentifier [FilePathSpec] ";"
| "library" LibraryIdentifier [FilePathSpec] "-incdir" [FilePathSpec] ";"

rules IncludeStatement ::= "include" FilePathSpec";";


-- A.1.2 System Verilog Source Text (Done)
rules SourceText ::= TimeunitsDeclaration [Description] | [Description];
rules Description ::= ModuleDeclaration 
                    | UdpDeclaration 
                    | InterfaceDeclaration 
                    | ProgramDeclaration 
                    | PackageDeclaration 
                    | [AttributeInstance] PackageItem 
                    | [AttributeInstance] BindDirective 
                    | ConfigDeclaration ;

rules ModuleNonansiHeader ::=  
[ AttributeInstance ] ModuleKeyword ModuleIdentifier [ PackageImportDeclaration ] ListOfPorts ";" |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier [ PackageImportDeclaration ] ListOfPorts ";" |
[ AttributeInstance ] ModuleKeyword ModuleIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPorts ";" |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPorts ";";

rules ModuleAnsiHeader ::= 
[ AttributeInstance ] ModuleKeyword ModuleIdentifier [ PackageImportDeclaration ] ";" |
[ AttributeInstance ] ModuleKeyword ModuleIdentifier [ PackageImportDeclaration ] ListOfPortDeclarations ";" |
[ AttributeInstance ] ModuleKeyword ModuleIdentifier [ PackageImportDeclaration ] ParameterPortList ";" |
[ AttributeInstance ] ModuleKeyword ModuleIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPortDeclarations ";" |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier [ PackageImportDeclaration ] ";" |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier [ PackageImportDeclaration ] ListOfPortDeclarations ";" |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier [ PackageImportDeclaration ] ParameterPortList ";" |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPortDeclarations ";";

rules ModuleDeclaration ::= 
ModuleNonansiHeader [ ModuleItem ] "endmodule" | 
ModuleNonansiHeader [ ModuleItem ] "endmodule" ":" ModuleIdentifier | 
ModuleNonansiHeader TimeunitsDeclaration [ ModuleItem ] "endmodule" | 
ModuleNonansiHeader TimeunitsDeclaration [ ModuleItem ] "endmodule" ":" ModuleIdentifier | 
ModuleAnsiHeader [ NonPortModuleItem ] "endmodule" | 
ModuleAnsiHeader [ NonPortModuleItem ] "endmodule" ":" ModuleIdentifier | 
ModuleAnsiHeader TimeunitsDeclaration [ NonPortModuleItem ] "endmodule" | 
ModuleAnsiHeader TimeunitsDeclaration [ NonPortModuleItem ] "endmodule" ":" ModuleIdentifier | 
[ AttributeInstance ] ModuleKeyword ModuleIdentifier "( .* ) ;" [ ModuleItem ] "endmodule" | 
[ AttributeInstance ] ModuleKeyword ModuleIdentifier "( .* ) ;" [ ModuleItem ] "endmodule" ":" ModuleIdentifier | 
[ AttributeInstance ] ModuleKeyword ModuleIdentifier "( .* ) ;" TimeunitsDeclaration [ ModuleItem ] "endmodule" | 
[ AttributeInstance ] ModuleKeyword ModuleIdentifier "( .* ) ;" TimeunitsDeclaration [ ModuleItem ] "endmodule" ":" ModuleIdentifier |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier "( .* ) ;" [ ModuleItem ] "endmodule" | 
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier "( .* ) ;" [ ModuleItem ] "endmodule" ":" ModuleIdentifier |
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier "( .* ) ;" TimeunitsDeclaration [ ModuleItem ] "endmodule" | 
[ AttributeInstance ] ModuleKeyword Lifetime ModuleIdentifier "( .* ) ;" TimeunitsDeclaration [ ModuleItem ] "endmodule" ":" ModuleIdentifier |
"extern" ModuleNonansiHeader |
"extern" ModuleAnsiHeader;

separator ModuleItem "";
separator NonPortModuleItem "";

rules ModuleKeyword ::= "module" | "macromodule";

rules InterfaceDeclaration ::= 
InterfaceNonAnsiHeader [ InterfaceItem ] "endinterface" | 
InterfaceNonAnsiHeader [ InterfaceItem ] "endinterface" ":" InterfaceIdentifier  | 
InterfaceNonAnsiHeader TimeunitsDeclaration [ InterfaceItem ] "endinterface" | 
InterfaceNonAnsiHeader TimeunitsDeclaration [ InterfaceItem ] "endinterface" ":" InterfaceIdentifier  |
InterfaceAnsiHeader [ InterfaceItem ] "endinterface" | 
InterfaceAnsiHeader [ InterfaceItem ] "endinterface" ":" InterfaceIdentifier  | 
InterfaceAnsiHeader TimeunitsDeclaration { NonPortInterfaceItem } "endinterface" | 
InterfaceAnsiHeader TimeunitsDeclaration { NonPortInterfaceItem } "endinterface" ":" InterfaceIdentifier  |
[ AttributeInstance ] "interface" InterfaceIdentifier "( .* ) ;" [ InterfaceItem ] "endinterface" |  
[ AttributeInstance ] "interface" InterfaceIdentifier "( .* ) ;" [ InterfaceItem ] "endinterface" ":" InterfaceIdentifier  |
[ AttributeInstance ] "interface" InterfaceIdentifier "( .* ) ;" TimeunitsDeclaration [ InterfaceItem ] "endinterface" |  
[ AttributeInstance ] "interface" InterfaceIdentifier "( .* ) ;" TimeunitsDeclaration [ InterfaceItem ] "endinterface" ":" InterfaceIdentifier  |
"extern" InterfaceNonAnsiHeader | 
"extern" InterfaceAnsiHeader;


rules InterfaceNonAnsiHeader ::= 
[ AttributeInstance ] "interface" InterfaceIdentifier [ PackageImportDeclaration ] ListOfPorts ";" |
[ AttributeInstance ] "interface" InterfaceIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPorts ";" |
[ AttributeInstance ] "interface" Lifetime InterfaceIdentifier [ PackageImportDeclaration ] ListOfPorts ";" |
[ AttributeInstance ] "interface" Lifetime InterfaceIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPorts ";";

rules InterfaceAnsiHeader ::= 
[ AttributeInstance ] "interface" InterfaceIdentifier [ PackageImportDeclaration ] ";" |
[ AttributeInstance ] "interface" InterfaceIdentifier [ PackageImportDeclaration ] ListOfPortDeclarations ";" |
[ AttributeInstance ] "interface" InterfaceIdentifier [ PackageImportDeclaration ] ParameterPortList ";" |
[ AttributeInstance ] "interface" InterfaceIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPortDeclarations ";" |
[ AttributeInstance ] "interface" Lifetime InterfaceIdentifier [ PackageImportDeclaration ] ";" |
[ AttributeInstance ] "interface" Lifetime InterfaceIdentifier [ PackageImportDeclaration ] ListOfPortDeclarations ";" |
[ AttributeInstance ] "interface" Lifetime InterfaceIdentifier [ PackageImportDeclaration ] ParameterPortList ";" |
[ AttributeInstance ] "interface" Lifetime InterfaceIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPortDeclarations ";";

rules ProgramDeclaration ::= 
ProgramNonAnsiHeader { ProgramItem } "endprogram" | 
ProgramNonAnsiHeader { ProgramItem } "endprogram" ":" ProgramIdentifier | 
ProgramNonAnsiHeader TimeunitsDeclaration { ProgramItem } "endprogram" | 
ProgramNonAnsiHeader TimeunitsDeclaration { ProgramItem } "endprogram" ":" ProgramIdentifier | 
ProgramAnsiHeader { ProgramItem } "endprogram" | 
ProgramAnsiHeader { ProgramItem } "endprogram" ":" ProgramIdentifier | 
ProgramAnsiHeader TimeunitsDeclaration { NonPortProgramItem } "endprogram" | 
ProgramAnsiHeader TimeunitsDeclaration { NonPortProgramItem } "endprogram" ":" ProgramIdentifier | 
[ AttributeInstance ] "program" ProgramIdentifier "( .* ) ;" { ProgramItem } "endprogram" | 
[ AttributeInstance ] "program" ProgramIdentifier "( .* ) ;" { ProgramItem } "endprogram" ":" ProgramIdentifier | 
[ AttributeInstance ] "program" ProgramIdentifier "( .* ) ;" TimeunitsDeclaration { ProgramItem } "endprogram" | 
[ AttributeInstance ] "program" ProgramIdentifier "( .* ) ;" TimeunitsDeclaration { ProgramItem } "endprogram" ":" ProgramIdentifier | 
"extern" ProgramNonAnsiHeader | 
"extern" ProgramAnsiHeader;

rules ProgramNonAnsiHeader ::= 
[ AttributeInstance ] "program" ProgramIdentifier [ PackageImportDeclaration ] ListOfPorts ";" |
[ AttributeInstance ] "program" ProgramIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPorts ";" |
[ AttributeInstance ] "program" Lifetime ProgramIdentifier [ PackageImportDeclaration ] ListOfPorts ";" |
[ AttributeInstance ] "program" Lifetime ProgramIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPorts ";";

rules ProgramAnsiHeader ::= 
[ AttributeInstance ] "program" ProgramIdentifier [ PackageImportDeclaration ] ";" |
[ AttributeInstance ] "program" ProgramIdentifier [ PackageImportDeclaration ] ListOfPortDeclarations ";" |
[ AttributeInstance ] "program" ProgramIdentifier [ PackageImportDeclaration ] ParameterPortList ";" |
[ AttributeInstance ] "program" ProgramIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPortDeclarations ";" |
[ AttributeInstance ] "program" Lifetime ProgramIdentifier [ PackageImportDeclaration ] ";" |
[ AttributeInstance ] "program" Lifetime ProgramIdentifier [ PackageImportDeclaration ] ListOfPortDeclarations ";" |
[ AttributeInstance ] "program" Lifetime ProgramIdentifier [ PackageImportDeclaration ] ParameterPortList ";" |
[ AttributeInstance ] "program" Lifetime ProgramIdentifier [ PackageImportDeclaration ] ParameterPortList ListOfPortDeclarations ";";

rules CheckerDeclaration ::= 
"checker" CheckerIdentifier ";" { CheckerOrGenerateItem } "endchecker" |
"checker" CheckerIdentifier ";" { CheckerOrGenerateItem } "endchecker" ":" CheckerIdentifier |
"checker" CheckerIdentifier "(" ")" ";" { CheckerOrGenerateItem } "endchecker" |
"checker" CheckerIdentifier "(" ")" ";" { CheckerOrGenerateItem } "endchecker" ":" CheckerIdentifier |
"checker" CheckerIdentifier "(" CheckerPortList ")" ";" { CheckerOrGenerateItem } "endchecker" |
"checker" CheckerIdentifier "(" CheckerPortList ")" ";" { CheckerOrGenerateItem } "endchecker" ":" CheckerIdentifier;

rules ClassDeclaration ::= 
"class" ClassIdentifier ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier ";" [ ClassItem ] "endclass" ":" ClassIdentifier |
"class" ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass" ":" ClassIdentifier |
"class" ClassIdentifier ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier ";" [ ClassItem ] "endclass" ":" ClassIdentifier |
"class" ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"class" ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier "extends" ClassType ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"virtual" "class" ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList ";" [ ClassItem ] "endclass"  ":" ClassIdentifier |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass" |
"virtual" "class" Lifetime ClassIdentifier ParameterPortList "extends" ClassType "(" ListOfArguments ")" ";" [ ClassItem ] "endclass"  ":" ClassIdentifier;

separator ClassItem "";

rules PackageDeclaration ::= 
[ AttributeInstance ] "package" PackageIdentifier ";" [ PackageWithAttr ] "endpackage" |
[ AttributeInstance ] "package" PackageIdentifier ";" [ PackageWithAttr ] "endpackage" ":" PackageIdentifier | 
[ AttributeInstance ] "package" PackageIdentifier ";" TimeunitsDeclaration [ PackageWithAttr ] "endpackage" |
[ AttributeInstance ] "package" PackageIdentifier ";" TimeunitsDeclaration [ PackageWithAttr ] "endpackage" ":" PackageIdentifier |
[ AttributeInstance ] "package" Lifetime PackageIdentifier ";" [ PackageWithAttr ] "endpackage" |
[ AttributeInstance ] "package" Lifetime PackageIdentifier ";" [ PackageWithAttr ] "endpackage" ":" PackageIdentifier | 
[ AttributeInstance ] "package" Lifetime PackageIdentifier ";" TimeunitsDeclaration [ PackageWithAttr ] "endpackage" |
[ AttributeInstance ] "package" Lifetime PackageIdentifier ";" TimeunitsDeclaration [ PackageWithAttr ] "endpackage" ":" PackageIdentifier;

rules PackageWithAttr ::= [ AttributeInstance ] PackageItem;

rules TimeunitsDeclaration ::= 
"timeunit" TimeLiteral ";" | 
"timeunit" TimeLiteral "/" TimeLiteral ";" | 
"timeprecision" TimeLiteral ";" | 
"timeunit" TimeLiteral ";" "timeprecision" TimeLiteral ";" | 
"timeprecision" TimeLiteral ";" "timeunit" TimeLiteral ";";

-- A.1.3 Module parameters and Port (Done)

rules ParameterPortList ::= 
"#" "(" ListOfParamAssignments [ ParameterPortDeclarationComma ] ")" | 
"#" "(" ParameterPortDeclaration [ ParameterPortDeclarationComma ] ")" | 
"#""(" ")";

rules ParameterPortDeclarationComma ::= "," ParameterPortDeclaration

rules ParameterPortDeclaration ::= 
ParameterDeclaration |
LocalParameterDeclaration |
DataType ListOfParamAssignments |
"type" ListOfTypeAssignments;

rules ListOfPorts ::= "(" [Port] ")";

rules ListOfPortDeclarations ::= 
"("  ")" |
"(" [AttributeInstanceWithAnsiPortDeclaration] ")";

rules AttributeInstanceWithAnsiPortDeclaration ::= [ AttributeInstance ] AnsiPortDeclaration;

rules PortDeclaration ::= 
[ AttributeInstance ] InoutDeclaration |
[ AttributeInstance ] InputDeclaration |
[ AttributeInstance ] OutputDeclaration |
[ AttributeInstance ] RefDeclaration |
[ AttributeInstance ] InterfacePortDeclaration;

rules Port ::= | PortExpression | "." PortIdentifier "(" ")" | "." PortIdentifier "(" PortExpression ")";

rules PortExpression ::= PortReference | "{" [PortReference] "}";

rules PortReference ::= PortIdentifier ConstantSelect;

rules PortDirection ::= "input" | "output" | "inout" | "ref";

rules NetPortHeader ::= NetPortType | PortDirection NetPortType;

rules VariablePortHeader ::= VariablePortType | PortDirection VariablePortType;

rules InterfacePortHeader ::=
InterfaceIdentifier | InterfaceIdentifier "." ModportIdentifier | 
"interface" | "interface" "." ModportIdentifier;

rules AnsiPortDeclaration ::= 
PortIdentifier [ UnpackedDimension ] |
PortIdentifier [ UnpackedDimension ] "=" ConstantExpression |
NetPortHeader PortIdentifier [ UnpackedDimension ] |
NetPortHeader PortIdentifier [ UnpackedDimension ] "=" ConstantExpression |  
InterfacePortHeader PortIdentifier [ UnpackedDimension ] |
InterfacePortHeader PortIdentifier [ UnpackedDimension ] "=" ConstantExpression |  
PortIdentifier [ VariableDimension ] | 
PortIdentifier [ VariableDimension ] "=" ConstantExpression |
VariablePortHeader PortIdentifier [ VariableDimension ] | 
VariablePortHeader PortIdentifier [ VariableDimension ] "=" ConstantExpression | 
"." PortIdentifier "(" ")" |
"." PortIdentifier "(" Expression ")" |
PortDirection "." PortIdentifier "(" ")" |
PortDirection "." PortIdentifier "(" Expression ")";

-- A.1.4 Module Items (Done)

rules ElaborationSystemTask ::= 
"$fatal" ";" | 
"$fatal" "(" FinishNumber ")" ";" |  
"$fatal" "(" FinishNumber "," ListOfArguments ")" ";" | 
"$error" ";" | 
"$error" "(" ")" ";" | 
"$error" "(" ListOfArguments ")" ";" | 
"$warning" ";" | 
"$warning" "(" ")" ";" | 
"$warning" "(" ListOfArguments ")" ";" | 
"$info" ";" |
"$info" "(" ")" ";" |
"$info" "(" ListOfArguments ")" ";";

rules FinishNumber ::= "0" | "1" | "2";

rules ModuleCommonItem ::= ModuleOrGenerateItemDeclaration 
| InterfaceInstantiation 
| ProgramInstantiation 
| AssertionItem 
| BindDirective 
| ContinuousAssign 
| NetAlias 
| InitialConstruct 
| FinalConstruct 
| AlwaysConstruct 
| LoopGenerateConstruct 
| ConditionalGenerateConstruct 
| ElaborationSystemTask;

rules ModuleItem ::= PortDeclaration ";"
| NonPortModuleItem;

rules ModuleOrGenerateItem ::= [ AttributeInstance ] ParameterOverride 
| [ AttributeInstance ] GateInstantiation 
| [ AttributeInstance ] UdpInstantiation 
| [ AttributeInstance ] ModuleInstantiation 
| [ AttributeInstance ] ModuleCommonItem;

rules ModuleOrGenerateItemDeclaration ::= PackageOrGenerateItemDeclaration 
| GenvarDeclaration 
| ClockingDeclaration 
| "default" "clocking" ClockingIdentifier ";"
| "default" "disable" "iff" ExpressionOrDist ";";

rules NonPortModuleItem ::= GenerateRegion 
| ModuleOrGenerateItem 
| SpecifyBlock 
| [ AttributeInstance ] SpecparamDeclaration 
| ProgramDeclaration 
| ModuleDeclaration 
| InterfaceDeclaration 
| TimeunitsDeclaration

rules ParameterOverride ::= "defparam" ListOfDefParamAssignments ";";

rules BindDirective ::= 
"bind" BindTargetScope BindInstantiation ";" |
"bind" BindTargetScope ":" BindTargetInstanceList BindInstantiation ";" |
"bind" BindTargetInstance BindInstantiation ";";

rules BindTargetScope ::= ModuleIdentifier | InterfaceIdentifier;
rules BindTargetInstance ::= HierarchicalIdentifier ConstantBitSelect ;
rules BindTargetInstanceList ::= [BindTargetInstance];
rules BindInstantiation ::= ProgramInstantiation | ModuleInstantiation | InterfaceInstantiation | CheckerInstantiation;

-- A.1.5 Configuration source text (Done)

rules ConfigDeclaration ::= 
"config" ConfigIdentifier ";" [ LocalParameterDeclaration ] DesignStatement [ ConfigRuleStatement ] "endconfig" |
"config" ConfigIdentifier ";" [ LocalParameterDeclaration ] DesignStatement [ ConfigRuleStatement ] "endconfig" ":" ConfigIdentifier;

rules DesignStatement ::= "design" [LibCellCombinedIdentifier] ";";

rules LibCellCombinedIdentifier ::= CellIdentifier | LibraryIdentifier "." CellIdentifier;

rules ConfigRuleStatement ::= 
DefaultClause LiblistClause ";"
| InstClause LiblistClause ";"
| InstClause UseClause ";"
| CellClause LiblistClause ";"
| CellClause UseClause ";";

rules DefaultClause ::= "default";
rules InstClause ::= "instance" InstName; 
rules InstName ::= TopModuleIdentifier [InstanceIdentifierWithDot]; 
rules InstanceIdentifierWithDot ::= "." InstanceIdentifier;

rules CellClause ::= 
"cell" CellIdentifier |
"cell" LibraryIdentifier "." CellIdentifier;

rules LiblistClause ::= "liblist" [LibraryIdentifier];

rules UseClause ::= 
"use" CellIdentifier | 
"use" CellIdentifier ":" "config" | 
"use" LibraryIdentifier "." CellIdentifier | 
"use" LibraryIdentifier "." CellIdentifier ":" "config" | 
"use" [NamedParameterAssignment] | 
"use" [NamedParameterAssignment] ":" "config" | 
"use" CellIdentifier [ NamedParameterAssignment ] | 
"use" CellIdentifier [ NamedParameterAssignment ] ":" "config" |
"use" LibraryIdentifier "." CellIdentifier [ NamedParameterAssignment ] | 
"use" LibraryIdentifier "." CellIdentifier [ NamedParameterAssignment ] ":" "config";

-- A.1.6 Interface items (Done)
rules InterfaceOrGenerateItem ::= 
[ AttributeInstance ] ModuleCommonItem 
| [ AttributeInstance ] ModportDeclaration 
| [ AttributeInstance ] ExternTfDeclaration

rules ExternTfDeclaration ::= "extern" MethodPrototype ";" | "extern" "forkjoin" TaskPrototype ";"

rules InterfaceItem ::= PortDeclaration ";" | NonPortInterfaceItem;

rules NonPortInterfaceItem ::= GenerateRegion 
| InterfaceOrGenerateItem 
| ProgramDeclaration 
| InterfaceDeclaration 
| TimeunitsDeclaration

-- A.1.7 Program items (Done)
rules ProgramItem ::= PortDeclaration ";" | NonPortProgramItem;


rules NonPortProgramItem ::= [ AttributeInstance ] ContinuousAssign 
| [ AttributeInstance ] ModuleOrGenerateItemDeclaration 
| [ AttributeInstance ] InitialConstruct 
| [ AttributeInstance ] FinalConstruct 
| [ AttributeInstance ] ConcurrentAssertionItem 
| [ AttributeInstance ] TimeunitsDeclaration
| ProgramGenerateItem ;

rules ProgramGenerateItem ::= LoopGenerateConstruct 
| ConditionalGenerateConstruct 
| GenerateRegion 
| ElaborationSystemTask;

-- A.1.8 Checker items (Done)

rules CheckerPortList ::= [CheckerPortItem];
rules CheckerPortItem ::= 
[ AttributeInstance ] PropertyFormalType PortIdentifier [VariableDimension] |
[ AttributeInstance ] PropertyFormalType PortIdentifier [VariableDimension] "=" PropertyActualArg ; 

rules CheckerOrGenerateItem ::= CheckerOrGenerateItemDeclaration 
| InitialConstruct
| CheckerAlwaysConstruct
| FinalConstruct
| AssertionItem
| CheckerGenerateItem;

rules CheckerOrGenerateItemDeclaration ::= 
DataDeclaration |
"rand" DataDeclaration |
FunctionDeclaration |
AssertionItemDeclaration |
CovergroupDeclaration  |
OverloadDeclaration |
GenvarDeclaration |
ClockingDeclaration |
"default" "clocking" ClockingIdentifier ";" |
"default" "disable" "iff" ExpressionOrDist ";" |
";";

rules CheckerGenerateItem ::= LoopGenerateConstruct
| ConditionalGenerateConstruct
| GenerateRegion
| ElaborationSystemTask;

rules CheckerAlwaysConstruct ::= "always" Statement;

-- A.1.9 Class items (Done)
rules ClassItem ::= 
[ AttributeInstance ] ClassProperty 
| [ AttributeInstance ] ClassMethod 
| [ AttributeInstance ] ClassConstraint 
| [ AttributeInstance ] ClassDeclaration 
| [ AttributeInstance ] CovergroupDeclaration 
| LocalParameterDeclaration ";"
| ParameterDeclaration ";"
| ";";

rules ClassProperty ::= [PropertyQualifier] DataDeclaration 
| "const" [ ClassItemQualifier ] DataType ConstIdentifier ";"
| "const" [ ClassItemQualifier ] DataType ConstIdentifier "=" ConstantExpression ";";

rules ClassMethod ::= 
[ MethodQualifier ] TaskDeclaration 
| [ MethodQualifier ] FunctionDeclaration 
| "extern" [ MethodQualifier ] MethodPrototype ";"
| [ MethodQualifier ] ClassConstructorDeclaration 
| "extern" [ MethodQualifier ] ClassConstructorPrototype;

rules ClassConstructorPrototype ::=  "function" "new" "(" ")" ";" | "function" "new" "(" TfPortList ")" ";";

rules ClassConstraint ::= ConstraintPrototype | ConstraintDeclaration;

rules ClassItemQualifier ::= "static" | "protected" | "local";

rules PropertyQualifier ::= RandomQualifier | ClassItemQualifier;

rules RandomQualifier ::= "rand" | "randc";

rules MethodQualifier ::= "virtual" | "pure" "virtual" | ClassItemQualifier;

rules MethodPrototype ::= TaskPrototype | FunctionPrototype;

rules ClassConstructorDeclaration ::= 
"function" "new" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" |
"function" "new" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" "new" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" "new" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" |
"function" "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" |
"function" "new" "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" ClassScope "new" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" |
"function" ClassScope "new" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" "new" |
"function" ClassScope "new" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" ClassScope "new" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" ClassScope "new" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" ClassScope "new" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" ClassScope "new" "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" |
"function" ClassScope "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" |
"function" ClassScope "new" "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" ClassScope "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" "new" |
"function" ClassScope "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" ClassScope "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" ClassScope "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" ClassScope "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction"  |
"function" ClassScope "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" ClassScope "new" "(" ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" ClassScope "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new"  |
"function" ClassScope "new" "(" TfPortList ")" ";" [ BlockItemDeclaration ] "super" "." "new" "(" ListOfArguments ")" ";"  [ FunctionStatementOrNull ] "endfunction" ":" "new";

-- A.1.10 Constraints (Done)

rules ConstraintDeclaration ::= 
"constraint" ConstraintIdentifier ConstraintBlock |
"static" "constraint" ConstraintIdentifier ConstraintBlock;

rules ConstraintBlock ::= "{" [ConstraintBlockItem] "}";

rules ConstraintBlockItem ::= "solve" SolveBeforeList "before" SolveBeforeList ";" | ConstraintExpression;

rules SolveBeforeList ::= [SolveBeforePrimary];

rules SolveBeforePrimary ::= 
HierarchicalIdentifier Select | 
ImplicitClassHandle "." HierarchicalIdentifier Select | 
ClassScope HierarchicalIdentifier Select;

rules ConstraintExpression ::= ExpressionOrDist ";" 
| Expression "–>" ConstraintSet 
| "if" "(" Expression ")" ConstraintSet
| "if" "(" Expression ")" ConstraintSet "else" ConstraintSet 
| "foreach" "(" PsOrHierarchicalArrayIdentifier ")" ConstraintSet
| "foreach" "(" PsOrHierarchicalArrayIdentifier LoopVariables ")" ConstraintSet;

rules ConstraintSet ::= ConstraintExpression | "{" [ConstraintExpression] "}";

rules DistList ::= [DistItem]; 
rules DistItem ::= ValueRange | ValueRange DistWeight;
rules DistWeight ::= ":=" Expression | ":/" Expression;

rules ConstraintPrototype ::= 
"constraint" ConstraintIdentifier ";" |
"static" "constraint" ConstraintIdentifier ";" |
ConstraintPrototypeQualifier "constraint" ConstraintIdentifier ";" |
ConstraintPrototypeQualifier "static" "constraint" ConstraintIdentifier ";" ;

rules ConstraintPrototypeQualifier ::= "extern" | "pure";

rules ExternConstraintDeclaration ::= 
"constraint" ClassScope ConstraintIdentifier ConstraintBlock
"static" "constraint" ClassScope ConstraintIdentifier ConstraintBlock

rules IdentifierList ::= [Ident];

-- A.1.11 Package Item (Done)
rules PackageItem ::= PackageOrGenerateItemDeclaration | AnonymousProgram | PackageExportDeclaration | TimeunitsDeclaration;

rules PackageOrGenerateItemDeclaration ::= NetDeclaration 
| DataDeclaration 
| TaskDeclaration 
| FunctionDeclaration 
| CheckerDeclaration 
| DpiImportExport 
| ExternConstraintDeclaration 
| ClassDeclaration 
| ClassConstructorDeclaration 
| LocalParameterDeclaration ";"
| ParameterDeclaration ";"
| CovergroupDeclaration 
| OverloadDeclaration 
| AssertionItemDeclaration 
| ";";

rules AnonymousProgram ::= "program" ";" [AnonymousProgramItem] "endprogram";

rules AnonymousProgramItem ::= TaskDeclaration 
| FunctionDeclaration 
| ClassDeclaration 
| CovergroupDeclaration 
| ClassConstructorDeclaration 
| ";";

-- A.2 Declarations
-- A.2.1. Declaration types (Done)
-- A.2.1.1 Module parameter declarations (Done)

rules LocalParameterDeclaration ::= "localparam" DataTypeOrImplicit ListOfParamAssignments | "localparam" "type" ListOfTypeAssignments;
rules ParameterDeclaration ::= "parameter" DataTypeOrImplicit ListOfParamAssignments | "parameter" "type" ListOfTypeAssignments;
rules SpecparamDeclaration ::= 
"specparam" ListOfSpecparamAssignments ";" |
"specparam" PackedDimension ListOfSpecparamAssignments ";";

-- A.2.1.2 Port declarations (Done)
rules InoutDeclaration ::= "inout" NetPortType ListOfPortIdentifiers;
rules InputDeclaration ::= "input" NetPortType ListOfPortIdentifiers | "input" VariablePortType ListOfVariableIdentifiers;
rules OutputDeclaration ::= "output" NetPortType ListOfPortIdentifiers | "output" VariablePortType ListOfVariablePortIdentifiers;
rules InterfacePortDeclaration ::= InterfaceIdentifier ListOfInterfaceIdentifiers | InterfaceIdentifier "." ModportIdentifier ListOfInterfaceIdentifiers; 
rules RefDeclaration ::= "ref" VariablePortType ListOfPortIdentifiers;

-- A.2.1.3 Type declarations (Done)

rules DataDeclaration ::= 
DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
Lifetime DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
"var" DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
"var" Lifetime DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
"const" DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
"const" Lifetime DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
"const" "var" DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
"const" "var" Lifetime DataTypeOrImplicit ListOfVariableDeclAssignments ";" |
TypeDeclaration | 
PackageImportDeclaration |
VirtualInterfaceDeclaration; 

rules PackageImportDeclaration ::= "import" [PackageImportItem] ";";
rules PackageImportItem ::= PackageIdentifier "::" Ident | PackageIdentifier "::" "*";
rules PackageExportDeclaration ::= "export" "*" "::" "*" ";" | "export" [PackageImportItem] ";";
rules GenvarDeclaration ::= "genvar" ListOfGenvarIdentifiers ";"

rules NetDeclaration ::= 
NetType DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType "vectored" DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType "vectored" DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType "scalared" DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType "scalared" DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType DriveStrength DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType DriveStrength DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType DriveStrength "vectored" DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType DriveStrength "vectored" DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType DriveStrength "scalared" DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType DriveStrength "scalared" DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType ChargeStrength DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType ChargeStrength DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType ChargeStrength "vectored" DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType ChargeStrength "vectored" DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";" |
NetType ChargeStrength "scalared" DataTypeOrImplicit ListOfNetDeclAssignments ";" |
NetType ChargeStrength "scalared" DataTypeOrImplicit Delay3 ListOfNetDeclAssignments ";";

rules TypeDeclaration ::= 
"typedef" DataType TypeIdentifier [VariableDimension] ";"
| "typedef" InterfaceInstanceIdentifier ConstantBitSelect "." TypeIdentifier TypeIdentifier ";"
| "typedef" TypeIdentifier ";"
| "typedef" "enum" TypeIdentifier ";"
| "typedef" "struct" TypeIdentifier ";"
| "typedef" "union" TypeIdentifier ";"
| "typedef" "class" TypeIdentifier ";";

rules Lifetime ::= "static" | "automatic";

-- A.2.2 Declaration data types (Done)
-- A.2.2.1 Net and variable types (Done)

rules CastingType ::= SimpleType | ConstantPrimary | Signing | "string" | "const";

rules DataType ::= 
IntegerVectorType [ PackedDimension ] |
IntegerVectorType Signing [ PackedDimension ] |
IntegerAtomType |
IntegerAtomType Signing |
NonIntegerType | 
StructUnion "{" [ StructUnionMember ] "}" [ PackedDimension ]| 
StructUnion "packed" "{" [ StructUnionMember ] "}" [ PackedDimension ]| 
StructUnion "packed" Signing "{" [ StructUnionMember ] "}" [ PackedDimension ]| 
"enum" "{" [EnumNameDeclaration] "}" [ PackedDimension ] | 
"enum" EnumBaseType "{" [EnumNameDeclaration] "}" [ PackedDimension ] | 
"string"| 
"chandle"| 
"virtual" InterfaceIdentifier | 
"virtual" "interface" InterfaceIdentifier | 
TypeIdentifier [ PackedDimension ] | 
ClassScope TypeIdentifier [ PackedDimension ] | 
PackageScope TypeIdentifier [ PackedDimension ] | 
ClassType | 
"event"| 
PsCovergroupIdentifier | 
TypeReference;

rules DataTypeOrImplicit ::= DataType | ImplicitDataType;

rules ImplicitDataType ::= 
[ PackedDimension ] |
Signing [ PackedDimension ]; 

rules EnumBaseType ::= 
IntegerAtomType 
| IntegerAtomType Signing 
| IntegerVectorType 
| IntegerVectorType PackedDimension 
| IntegerVectorType Signing  
| IntegerVectorType Signing PackedDimension 
| TypeIdentifier
| TypeIdentifier [ PackedDimension ]

rules EnumNameDeclaration ::= 
EnumIdentifier |
EnumIdentifier "=" ConstantExpression |
EnumIdentifier "[" IntegralNumber "]" |
EnumIdentifier "[" IntegralNumber "]" "=" ConstantExpression|
EnumIdentifier "[" IntegralNumber ":" IntegralNumber "]"  |
EnumIdentifier "[" IntegralNumber ":" IntegralNumber "]" "=" ConstantExpression;

rules ClassScope ::= ClassType "::";

rules ClassType ::= 
PsClassIdentifier |
PsClassIdentifier ParameterValueAssignment |
[ ScopedClassIdentifiedMaybeParamValueAssignment ];

rules ScopedClassIdentifiedMaybeParamValueAssignment ::= "::" ClassIdentifier | "::" ClassIdentifier ParameterValueAssignment;

rules IntegerType ::= IntegerVectorType | IntegerAtomType;

rules IntegerAtomType ::= "byte" | "shortint" | "int" | "longint" | "integer" | "time";
rules IntegerVectorType ::= "bit" | "logic" | "reg";
rules NonIntegerType ::= "shortreal" | "real" | "realtime";
rules NetType ::= "supply0" | "supply1" | "tri" | "triand" | "trior" | "trireg"| "tri0" | "tri1" | "uwire"| "wire" | "wand" | "wor";

rules NetPortType ::= DataTypeOrImplicit | NetType DataTypeOrImplicit; 
rules VariablePortType ::= VarDataType;
rules VarDataType ::= DataType | "var" DataTypeOrImplicit;

rules Signing ::= "signed" | "unsigned";
rules SimpleType ::= IntegerType | NonIntegerType | PsTypeIdentifier | PsParameterIdentifier;

rules StructUnionMember ::= 
[ AttributeInstance ] DataTypeOrVoid ListOfVariableDeclAssignments ";" |
[ AttributeInstance ] RandomQualifier DataTypeOrVoid ListOfVariableDeclAssignments ";";

rules DataTypeOrVoid ::= DataType | "void";
rules StructUnion ::= "struct" | "union" | "union" "tagged"; 
rules TypeReference ::= "type" "(" Expression ")" | "type" "(" DataType ")";

-- A.2.2.2 Strengths (Done)
rules DriveStrength ::= 
"(" Strength0 "," Strength1 ")"
| "(" Strength1 "," Strength0 ")"
| "(" Strength0 "," "highz1" ")"
| "(" Strength1 "," "highz0" ")"
| "(" "highz0" "," Strength1 ")"
| "(" "highz1" "," Strength0 ")";

rules Strength0 ::= "supply0" | "strong0" | "pull0" | "weak0";
rules Strength1 ::= "supply1" | "strong1" | "pull1" | "weak1";
rules ChargeStrength ::= "(" "small" ")" | "(" "medium" ")" | "(" "large" ")";

-- A.2.2.3 Delays (Done)
rules Delay3 ::= 
"#" DelayValue | 
"#" "(" MintypmaxExpression ")" |
"#" "(" MintypmaxExpression "," MintypmaxExpression ")" |
"#" "(" MintypmaxExpression "," MintypmaxExpression "," MintypmaxExpression ")" ;

rules Delay2 ::= 
"#" DelayValue |
 "#" "(" MintypmaxExpression ")" |
 "#" "(" MintypmaxExpression "," MintypmaxExpression ")";

rules DelayValue ::= 
UnsignedNumber 
| RealNumber 
| PsIdentifier 
| TimeLiteral 
| "1step";

-- A.2.3 Declaration lists (Done)

rules ListOfDefParamAssignments ::= [DefparamAssignment];
rules ListOfGenvarIdentifiers ::= [GenvarIdentifier];
rules ListOfInterfaceIdentifiers ::= [InterfaceIdentifierWithUpackedDimension];
rules ListOfNetDeclAssignments ::= [NetDeclAssignment];
rules ListOfParamAssignments ::= [ParamAssignment]; 
rules ListOfPortIdentifiers ::= [PortIdentifierWithUnpackedDimension];
rules ListOfUdpPortIdentifiers ::= [PortIdentifier]; 
rules ListOfSpecparamAssignments ::= [SpecparamAssignment];
rules ListOfTfVariableIdentifiers ::= [TfVariableIdentifier];
rules ListOfTypeAssignments ::= [TypeAssignment]; 
rules ListOfVariableDeclAssignments ::= [VariableDeclAssignment];
rules ListOfVariableIdentifiers ::= [VariableIdentifierWithVariableDimension];
rules ListOfVariablePortIdentifiers ::= [VariablePortIdentifierWithVariableDimension];
rules ListOfVirtualInterfaceDecl ::= [VariableIdentifierWithInstanceIdentifier];

rules InterfaceIdentifierWithUpackedDimension ::= InterfaceIdentifier [ UnpackedDimension ];
rules PortIdentifierWithUnpackedDimension ::= PortIdentifier [ UnpackedDimension ];
rules TfVariableIdentifier ::= PortIdentifier [ VariableDimension ] | PortIdentifier [ VariableDimension ] "=" Expression;
rules VariableIdentifierWithVariableDimension ::=  VariableIdentifier [ VariableDimension ];
rules VariablePortIdentifierWithVariableDimension ::= PortIdentifier [ VariableDimension ] | PortIdentifier [ VariableDimension ] "=" ConstantExpression
rules VariableIdentifierWithInstanceIdentifier ::=  VariableIdentifier |  VariableIdentifier "=" InterfaceInstanceIdentifier ;

separator nonempty GenvarIdentifier ",";
separator nonempty InterfaceIdentifierWithUpackedDimension ",";
separator nonempty NetDeclAssignment ",";
separator nonempty ParamAssignment ",";
separator nonempty PortIdentifierWithUnpackedDimension ",";
separator nonempty PortIdentifier ",";
separator nonempty SpecparamAssignment ",";
separator nonempty TfVariableIdentifier ",";
separator nonempty TypeAssignment "," ;
separator nonempty VariableDeclAssignment ",";
separator nonempty VariableIdentifierWithVariableDimension ",";
separator nonempty VariablePortIdentifierWithVariableDimension ",";
separator nonempty VariableIdentifierWithInstanceIdentifier ",";

-- A.2.4 Declaration assignments (Done)
rules DefparamAssignment ::= HierarchicalParameterIdentifier "=" ConstantMintypmaxExpression ;
rules NetDeclAssignment ::= NetIdentifier [ UnpackedDimension ] | NetIdentifier [ UnpackedDimension ] "=" Expression ;
rules ParamAssignment ::= 
ParameterIdentifier [ UnpackedDimension ] 
| ParameterIdentifier [ UnpackedDimension ] "=" ConstantParamExpression;

rules SpecparamAssignment ::= SpecparamIdentifier "=" ConstantMintypmaxExpression | PulseControlSpecparam ;
rules TypeAssignment ::= TypeIdentifier | TypeIdentifier "=" DataType;

rules PulseControlSpecparam ::= 
"PATHPULSE$" "=" "(" RejectLimitValue ")"
| "PATHPULSE$" "=" "(" RejectLimitValue "," ErrorLimitValue ")"
| "PATHPULSE$"SpecifyInputTerminalDescriptor"$"SpecifyOutputTerminalDescriptor "=" "(" RejectLimitValue ")"
| "PATHPULSE$"SpecifyInputTerminalDescriptor"$"SpecifyOutputTerminalDescriptor "=" "(" RejectLimitValue "," ErrorLimitValue ")";

rules ErrorLimitValue ::= LimitValue ;
rules RejectLimitValue ::= LimitValue ;
rules LimitValue ::= ConstantMintypmaxExpression ; 
rules VariableDeclAssignment ::= 
VariableIdentifier [ VariableDimension ] MaybeAssignExpression 
| DynamicArrayVariableIdentifier UnsizedDimension [ VariableDimension ] MaybeAssignDynamicArrayNew 
| ClassVariableIdentifier MaybeAssignClassNew;

rules ClassNew ::= "new" | "new" Expression | "new" "(" ListOfArguments ")"; 
rules DynamicArrayNew ::= "new" "[" Expression "]" MaybeEnclosedExpression; 

rules MaybeAssignExpression ::= | "=" Expression;
rules MaybeAssignDynamicArrayNew ::= | "=" DynamicArrayNew ;
rules MaybeAssignClassNew ::= | "=" ClassNew;
rules MaybeEnclosedExpression ::= |  "(" Expression ")";

-- A.2.5 Declaration ranges (Done) 
rules UnpackedDimension ::= "[" ConstantRange "]" | "[" ConstantExpression "]";
rules PackedDimension ::= "[" ConstantRange "]" | UnsizedDimension ;
rules AssociativeDimension ::= "[" DataType "]" | "[" "*" "]";
rules VariableDimension ::= 
UnsizedDimension 
| UnpackedDimension 
| AssociativeDimension 
| QueueDimension ;

rules QueueDimension ::= "[" "$"  "]" | "[" "$" ":" ConstantExpression "]";
rules UnsizedDimension ::= "[" "]";

separator UnpackedDimension "";

-- A.2.6 Function declarations (Done)
rules FunctionDataTypeOrImplicit ::= DataTypeOrVoid | ImplicitDataType ;
rules FunctionDeclaration ::= "function" FunctionBodyDeclaration | "function" Lifetime FunctionBodyDeclaration;

rules FunctionBodyDeclaration ::= 
FunctionDataTypeOrImplicit FunctionIdentifier ";" [ TfItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" 
| FunctionDataTypeOrImplicit FunctionIdentifier ";" [ TfItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier
| FunctionDataTypeOrImplicit InterfaceIdentifier "." FunctionIdentifier ";" [ TfItemDeclaration ] [ FunctionStatementOrNull ] "endfunction"
| FunctionDataTypeOrImplicit InterfaceIdentifier "." FunctionIdentifier ";" [ TfItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier
| FunctionDataTypeOrImplicit ClassScope FunctionIdentifier ";" [ TfItemDeclaration ] [ FunctionStatementOrNull ] "endfunction"
| FunctionDataTypeOrImplicit ClassScope FunctionIdentifier ";" [ TfItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier

| FunctionDataTypeOrImplicit FunctionIdentifier "("  ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" 
| FunctionDataTypeOrImplicit FunctionIdentifier "("  ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier

| FunctionDataTypeOrImplicit FunctionIdentifier "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" 
| FunctionDataTypeOrImplicit FunctionIdentifier "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier

| FunctionDataTypeOrImplicit InterfaceIdentifier "." FunctionIdentifier "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" 
| FunctionDataTypeOrImplicit InterfaceIdentifier "." FunctionIdentifier "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier

| FunctionDataTypeOrImplicit InterfaceIdentifier "." FunctionIdentifier "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" 
| FunctionDataTypeOrImplicit InterfaceIdentifier "." FunctionIdentifier "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier

| FunctionDataTypeOrImplicit ClassScope FunctionIdentifier "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" 
| FunctionDataTypeOrImplicit ClassScope FunctionIdentifier "(" ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier

| FunctionDataTypeOrImplicit ClassScope FunctionIdentifier "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" 
| FunctionDataTypeOrImplicit ClassScope FunctionIdentifier "(" TfPortList ")" ";" [ BlockItemDeclaration ] [ FunctionStatementOrNull ] "endfunction" ":" FunctionIdentifier;

rules FunctionPrototype ::= 
function DataTypeOrVoid FunctionIdentifier "(" ")" 
| function DataTypeOrVoid FunctionIdentifier "(" TfPortList ")";

rules DpiImportExport ::= 
"import" DpiSpecString DpiFunctionProto ";"
| "import" DpiSpecString CIdentifier "=" DpiFunctionProto ";"
| "import" DpiSpecString DpiFunctionImportProperty DpiFunctionProto ";"
| "import" DpiSpecString DpiFunctionImportProperty CIdentifier "=" DpiFunctionProto ";"
| "import" DpiSpecString DpiTaskProto ";"
| "import" DpiSpecString CIdentifier "=" DpiTaskProto ";"
| "import" DpiSpecString DpiTaskImportProperty DpiTaskProto ";"
| "import" DpiSpecString DpiTaskImportProperty CIdentifier "=" DpiTaskProto ";"
| "export" DpiSpecString "function" FunctionIdentifier ";"
| "export" DpiSpecString CIdentifier "=" "function" FunctionIdentifier ";"
| "export" DpiSpecString "task" TaskIdentifier ";"
| "export" DpiSpecString CIdentifier "=" "task" TaskIdentifier ";";

rules DpiSpecString ::= "\"DPI-C\"" | "\"DPI\"";
rules DpiFunctionImportProperty ::= "context" | "pure";
rules DpiTaskImportProperty ::= "context";
rules DpiFunctionProto ::= FunctionPrototype ;
rules DpiTaskProto ::= TaskPrototype;

separator FunctionStatementOrNull "";
separator BlockItemDeclaration "";

-- A.2.7 Task declarations (Done)
rules TaskDeclaration ::= "task" TaskBodyDeclaration | task Lifetime TaskBodyDeclaration; 
rules TaskBodyDeclaration ::= 
| TaskIdentifier ";" [ TfItemDeclaration ] [ StatementOrNull ] "endtask" MaybeTaskIdentifierFooter 
| InterfaceIdentifier "." TaskIdentifier ";" [ TfItemDeclaration ] [ StatementOrNull ] "endtask" MaybeTaskIdentifierFooter 
| ClassScope TaskIdentifier ";" [ TfItemDeclaration ] [ StatementOrNull ] "endtask" MaybeTaskIdentifierFooter;

| TaskIdentifier "(" MaybeTfPortList ")" ";" [ BlockItemDeclaration ] [ StatementOrNull ] "endtask" MaybeTaskIdentifierFooter
| InterfaceIdentifier "." TaskIdentifier "(" MaybeTfPortList ")" ";" [ BlockItemDeclaration ] [ StatementOrNull ] "endtask" MaybeTaskIdentifierFooter
| ClassScope TaskIdentifier "(" MaybeTfPortList ")" ";" [ BlockItemDeclaration ] [ StatementOrNull ] "endtask" MaybeTaskIdentifierFooter;

rules TfItemDeclaration ::= 
BlockItemDeclaration 
| TfPortDeclaration ;

rules TfPortList ::= [TfPortItem];
rules TfPortItem ::= [ AttributeInstance ] MaybeTfPortDirection MaybeVar DataTypeOrImplicit MaybePortExpression;

rules TfPortDirection ::= PortDirection | "const" "ref";
rules TfPortDeclaration ::= [ AttributeInstance ] TfPortDirection MaybeVar DataTypeOrImplicit ListOfTfVariableIdentifiers ";";
rules TaskPrototype ::= "task" TaskIdentifier "(" MaybeTfPortList ")";

rules MaybeTaskIdentifierFooter ::= | ":" TaskIdentifier;
rules MaybeTfPortList ::= | TfPortList;
rules MaybeTfPortDirection ::= | TfPortDirection;
rules MaybeVar ::= | "var";
rules MaybePortExpression ::= |  PortIdentifier [ VariableDimension ] MaybeExpression;

separator nonempty TfPortItem ",";
separator TfItemDeclaration "";

-- A.2.8 Block item declarations (Done) 
rules BlockItemDeclaration ::= 
[ AttributeInstance ] DataDeclaration 
| [ AttributeInstance ] LocalParameterDeclaration ";"
| [ AttributeInstance ] ParameterDeclaration ";"
| [ AttributeInstance ] OverloadDeclaration 
| [ AttributeInstance ] LetDeclaration ;
rules OverloadDeclaration ::= "bind" OverloadOperator "function" DataType FunctionIdentifier "(" OverloadProtoFormals ")" ";";
rules OverloadOperator ::= "+" | "++" | "–" | "– –" | "*" | "**" | "/" | "%" | "==" | "!=" | "<" | "<=" | ">" | ">=" | "=";
rules OverloadProtoFormals ::= [DataType];

separator nonempty DataType ",";

-- A.2.9 Interface declarations (Done)
rules VirtualInterfaceDeclaration ::= 
"virtual" InterfaceIdentifier MaybeParameterValueAssignment MaybeModportIdentifier ListOfVirtualInterfaceDecl ";"
| "virtual" "interface" InterfaceIdentifier MaybeParameterValueAssignment MaybeModportIdentifier ListOfVirtualInterfaceDecl ";";

rules ModportDeclaration ::= "modport" [ModportItem] ";";

rules ModportItem ::= ModportIdentifier "(" [ModportPortsDeclaration]")"
rules ModportPortsDeclaration ::=
[ AttributeInstance ] ModportSimplePortsDeclaration 
| [ AttributeInstance ] ModportTfPortsDeclaration 
| [ AttributeInstance ] ModportClockingDeclaration;

rules ModportClockingDeclaration ::= "clocking" ClockingIdentifier ;
rules ModportSimplePortsDeclaration ::= PortDirection [ModportSimplePort];

rules ModportSimplePort ::= PortIdentifier | "." PortIdentifier "(" MaybeExpression ")";
rules ModportTfPortsDeclaration ::= ImportExport [ModportTfPort];

rules ModportTfPort ::= MethodPrototype | TfIdentifier ;
rules ImportExport ::= "import" | "export";

rules MaybeModportIdentifier ::= | "." ModportIdentifier;
separator nonempty ModportItem ",";
separator nonempty ModportPortsDeclaration ",";
separator nonempty ModportSimplePort ",";
separator nonempty ModportTfPort ",";

-- A.2.10 Assertion declarations (Done)

rules ConcurrentAssertionItem ::= 
MaybeBlockIdentifierHeader ConcurrentAssertionStatement 
| CheckerInstantiation;

rules ConcurrentAssertionStatement ::= 
AssertPropertyStatement 
| AssumePropertyStatement 
| CoverPropertyStatement 
| CoverSequenceStatement 
| RestrictPropertyStatement;

rules AssertPropertyStatement::= "assert" "property" "(" PropertySpec ")" ActionBlock ;
rules AssumePropertyStatement::= "assume" "property" "(" PropertySpec ")" ActionBlock ;
rules CoverPropertyStatement::= "cover" "property" "(" PropertySpec ")" StatementOrNull;

rules ExpectPropertyStatement ::= "expect" "(" PropertySpec ")" ActionBlock ;
rules CoverSequenceStatement::= "cover" "sequence" "(" MaybeClockingEvent [ "disable" "iff" "(" ExpressionOrDist ")" ] SequenceExpr ")" StatementOrNull ;
rules RestrictPropertyStatement::= "restrict" "property" "(" PropertySpec ")" ";";

rules PropertyInstance ::= 
PsOrHierarchicalPropertyIdentifier 
| PsOrHierarchicalPropertyIdentifier "(" ")"
| PsOrHierarchicalPropertyIdentifier "(" PropertyListOfArguments ")";

rules PropertyListOfArguments ::= 
[ MaybePropertyActualArg ] [ MaybePropertyActualArgCont ] 
| "." Ident "(" MaybePropertyActualArg ")" [ MaybePropertyActualArgCont ];

rules PropertyActualArg ::= PropertyExpr | SequenceActualArg ;
rules AssertionItemDeclaration ::= PropertyDeclaration | SequenceDeclaration | LetDeclaration ;

rules PropertyDeclaration ::= 
"property" PropertyIdentifier ";" [ AssertionVariableDeclaration ] PropertyStatementSpec "endproperty" MaybePropertyIdentifierFooter 
| "property" PropertyIdentifier "(" MaybePropertyPortList ")" ";" [ AssertionVariableDeclaration ] PropertyStatementSpec "endproperty" MaybePropertyIdentifierFooter;

rules PropertyPortList ::= [PropertyPortItem];

rules PropertyPortItem ::= 
[ AttributeInstance ] PropertyFormalType PortIdentifier [ VariableDimension ] 
| [ AttributeInstance ] PropertyFormalType PortIdentifier [ VariableDimension ] "=" PropertyActualArg
| [ AttributeInstance ] "local" PropertyFormalType PortIdentifier [ VariableDimension ] 
| [ AttributeInstance ] "local" PropertyFormalType PortIdentifier [ VariableDimension ] "=" PropertyActualArg
| [ AttributeInstance ] "local" PropertyLvarPortDirection PropertyFormalType PortIdentifier [ VariableDimension ] 
| [ AttributeInstance ] "local" PropertyLvarPortDirection PropertyFormalType PortIdentifier [ VariableDimension ] "=" PropertyActualArg;

rules PropertyLvarPortDirection ::= "input";
rules PropertyFormalType ::= SequenceFormalType | "property";

rules PropertySpec ::= MaybeClockingEvent MaybeDisableIffExpressionOrDist PropertyExpr ;
rules PropertyStatementSpec ::= MaybeClockingEvent MaybeDisableIffExpressionOrDist PropertyStatement;

rules PropertyStatement ::= PropertyExpr ";"
| "case" "(" ExpressionOrDist ")" [ PropertyCaseItem ] "endcase"
| "if" "(" ExpressionOrDist ")" PropertyExpr 
| "if" "(" ExpressionOrDist ")" PropertyExpr "else" PropertyExpr;

rules PropertyCaseItem::= 
ExpressionOrDist ":" PropertyStatement 
| ":" PropertyStatement 
| "default" PropertyStatement 
| "default" ":" PropertyStatement ;

rules PropertyExpr ::= 
SequenceExpr 
| "strong" "(" SequenceExpr ")"
| "weak" "(" SequenceExpr ")"
| "(" PropertyExpr ")"
| "not" PropertyExpr
| PropertyExpr "or" PropertyExpr 
| PropertyExpr "and" PropertyExpr 
| SequenceExpr "|->" PropertyExpr 
| SequenceExpr "|=>" PropertyExpr 
| PropertyStatement 
| SequenceExpr "#-#" PropertyExpr 
| SequenceExpr "#=#" PropertyExpr 
| "nexttime" PropertyExpr 
| "nexttime" "[" ConstantExpression "]" PropertyExpr 
| "s_nexttime" PropertyExpr 
| "s_nexttime" "[" ConstantExpression "]" PropertyExpr 
| "always" PropertyExpr 
| "always" "[" CycleDelayConstRangeExpression "]" PropertyExpr 
| "s_always" "[" constant_range"]" PropertyExpr 
| "s_eventually" PropertyExpr 
| "eventually" "[" constant_range "]" PropertyExpr 
| "s_eventually" "[" CycleDelayConstRangeExpression "]" PropertyExpr 
| PropertyExpr "until" PropertyExpr 
| PropertyExpr "s_until" PropertyExpr 
| PropertyExpr "until_with" PropertyExpr 
| PropertyExpr "s_until_with" PropertyExpr 
| PropertyExpr "implies" PropertyExpr 
| PropertyExpr "iff" PropertyExpr
| "accept_on" "(" ExpressionOrDist ")" PropertyExpr 
| "reject_on" "(" ExpressionOrDist ")" PropertyExpr 
| "sync_accept_on" "(" ExpressionOrDist ")" PropertyExpr 
| "sync_reject_on" "(" ExpressionOrDist ")" PropertyExpr 
| PropertyInstance 
| ClockingEvent PropertyExpr;

rules SequenceDeclaration ::= 
"sequence" SequenceIdentifier ";" [ AssertionVariableDeclaration ] SequenceExpr ";" "endsequence" MaybeSequenceIdentifierFooter
| "sequence" SequenceIdentifier "(" MaybeSequencePortLists ")" ";" [ AssertionVariableDeclaration ] SequenceExpr ";" "endsequence" MaybeSequenceIdentifierFooter;

rules SequencePortList ::= [SequencePortItem];

rules SequencePortItem ::= 
[ AttributeInstance ] SequenceFormalType PortIdentifier [ VariableDimension ] 
| [ AttributeInstance ] SequenceFormalType PortIdentifier [ VariableDimension ] "=" SequenceActualArg
| [ AttributeInstance ] "local" SequenceFormalType PortIdentifier [ VariableDimension ] 
| [ AttributeInstance ] "local" SequenceFormalType PortIdentifier [ VariableDimension ] "=" SequenceActualArg
| [ AttributeInstance ] "local" SequenceLvarPortDirection SequenceFormalType PortIdentifier [ VariableDimension ] 
| [ AttributeInstance ] "local" SequenceLvarPortDirection SequenceFormalType PortIdentifier [ VariableDimension ] "=" SequenceActualArg;

rules SequenceLvarPortDirection ::= "input" | "inout" | "output";
rules SequenceFormalType ::= 
DataTypeOrImplicit 
| "sequence"
| "event"
| "untyped";

rules SequenceExpr ::= 
[ CycleDelayRangeAndSequenceExpr ]
| SequenceExpr [ CycleDelayRangeAndSequenceExpr ]
| ExpressionOrDist  
| ExpressionOrDist BooleanAbbrev
| SequenceInstance  
| SequenceInstance SequenceAbbrev 
| "(" SequenceExpr [ SequenceMatchItemCont ] ")"  
| "(" SequenceExpr [ SequenceMatchItemCont ] ")" SequenceAbbrev 
| SequenceExpr "and" SequenceExpr
| SequenceExpr "intersect" SequenceExpr 
| SequenceExpr "or" SequenceExpr 
| "first_match" "(" SequenceExpr [ SequenceMatchItemCont ]")"
| ExpressionOrDist "throughout" SequenceExpr 
| SequenceExpr "within" SequenceExpr 
| ClockingEvent SequenceExpr;

rules CycleDelayRange ::= 
"##" ConstantPrimary 
| "##" "[" CycleDelayConstRangeExpression "]"
| "##""[*]"
| "##""[+]";

rules SequenceMethodCall ::= 
SequenceInstance "." MethodIdentifier ;

rules SequenceMatchItem ::= 
OperatorAssignment 
| IncOrDecExpression 
| SubroutineCall;


rules SequenceInstance ::= 
PsOrHierarchicalSequenceIdentifier
| PsOrHierarchicalSequenceIdentifier "(" ")"
| PsOrHierarchicalSequenceIdentifier "(" SequenceListOfArguments ")";

rules SequenceListOfArguments ::= 
[ MaybeSequenceActualArg ] [ SequenceActualArgCont ] 
| "." Ident "(" MaybeSequenceActualArg ")" [ SequenceActualArgCont ] ;

rules SequenceActualArg ::= EventExpression | SequenceExpr; 
rules BooleanAbbrev ::= ConsecutiveRepetition | NonConsecutiveRepetition | GotoRepetition;
rules SequenceAbbrev ::= ConsecutiveRepetition ;
rules ConsecutiveRepetition ::= 
"[" "*" ConstOrRangeExpression "]"
| "[*]"
| "[+]";

rules NonConsecutiveRepetition ::= "[""=" ConstOrRangeExpression "]";
rules GotoRepetition ::= "[""->" ConstOrRangeExpression "]";

rules ConstOrRangeExpression ::= ConstantExpression | CycleDelayConstRangeExpression ;

rules CycleDelayConstRangeExpression ::= ConstantExpression ":" ConstantExpression | ConstantExpression ":" "$";

rules ExpressionOrDist ::= Expression "dist" "{" DistList "}" | Expression;

rules AssertionVariableDeclaration ::= VarDataType ListOfVariableDeclAssignments ;

rules LetDeclaration ::= 
"let" LetIdentifier "=" Expression ";"
| "let" LetIdentifier "(" ")" "=" Expression ";"
| "let" LetIdentifier "(" LetPortList ")" "=" Expression ";";

rules LetIdentifier ::= Ident;

rules LetPortList ::= [ LetPortItem ];
rules LetPortItem ::= 
[ AttributeInstance ] LetFormalType PortIdentifier [ VariableDimension ]
| [ AttributeInstance ] LetFormalType PortIdentifier [ VariableDimension ] "=" Expression;

rules LetFormalType ::= DataTypeOrImplicit ;
rules LetExpression ::= 
MaybePackageScope LetIdentifier 
| MaybePackageScope LetIdentifier "(" ")" 
| MaybePackageScope LetIdentifier "(" LetListOfArguments ")" ;

rules LetListOfArguments ::= 
[ MaybeLetActualArg ] [ LetActualArgCont ]
| "." Ident "(" MaybeLetActualArg ")" [ LetActualArgCont ];

rules LetActualArg ::= Expression ;

rules CycleDelayRangeAndSequenceExpr ::= CycleDelayRange SequenceExpr;
rules SequenceMatchItemCont ::= "," SequenceMatchItem;
rules SequenceActualArgCont ::= "," "." Ident "(" MaybeSequenceActualArg ")";
rules LetActualArgCont ::= "," "." Ident "(" MaybeLetActualArg ")";

rules MaybeClockingEvent ::= | ClockingEvent;
rules MaybePropertyActualArgCont ::= | "," "." Ident "(" MaybePropertyActualArg ")";
rules MaybePropertyPortList ::= | PropertyPortList;
rules MaybePropertyIdentifierFooter ::= | ":" PropertyIdentifier;
rules MaybeDisableIffExpressionOrDist ::= | "disable" "iff" "(" ExpressionOrDist ")";
rules MaybeSequencePortLists ::= | SequencePortList;
rules MaybeSequenceIdentifierFooter ::= | ":" SequenceIdentifier;
rules MaybeSequenceActualArg ::= | SequenceActualArg;
rules MaybeLetActualArg ::= | LetActualArg;

separator nonempty MaybePropertyActualArg ",";
separator MaybePropertyActualArgCont "";
separator AssertionVariableDeclaration "";
separator nonempty PropertyPortItem ",";
separator nonempty PropertyCaseItem "";
separator nonempty ExpressionOrDist ",";
separator nonempty SequencePortItem ",";
separator nonempty CycleDelayRangeAndSequenceExpr "";
separator SequenceMatchItemCont "";
separator nonempty MaybeSequenceActualArg ",";
separator nonempty LetPortItem ",";
separator nonempty MaybeLetActualArg ",";

-- A.2.11 Covergroup declarations (Done)
rules CovergroupDeclaration ::= 
"covergroup" CovergroupIdentifier MaybeCoverageEvent ";" [ CoverageSpecOrOption ] "endgroup" MaybeCovergroupIdentifierFooter
| "covergroup" CovergroupIdentifier "(" MaybeTfPortList ")" MaybeCoverageEvent ";" [ CoverageSpecOrOption ] "endgroup" MaybeCovergroupIdentifierFooter;

rules CoverageSpecOrOption ::= 
[ AttributeInstance ] CoverageSpec 
| [ AttributeInstance ] CoverageOption ";";

rules CoverageOption ::= 
"option""."MemberIdentifier "=" Expression 
| "type" "option""."MemberIdentifier "=" ConstantExpression;

rules CoverageSpec ::= CoverPoint | CoverCross;

rules CoverageEvent ::= ClockingEvent 
| "with" "function" "sample" "(" MaybeTfPortList ")"
| "@@""(" BlockEventExpression ")";

rules BlockEventExpression ::= 
BlockEventExpression "or" BlockEventExpression 
| "begin" HierarchicalBtfIdentifier 
| "end" HierarchicalBtfIdentifier;

rules HierarchicalBtfIdentifier ::= 
HierarchicalTfIdentifier 
| HierarchicalBlockIdentifier 
| HierarchicalIdentifier MethodIdentifier 
| HierarchicalIdentifier class_scope MethodIdentifier;

rules CoverPoint ::= 
"coverpoint" Expression BinsOrEmpty
| "coverpoint" Expression "iff" "(" Expression ")" BinsOrEmpty
| CoverPointIdentifier ":" "coverpoint" Expression BinsOrEmpty
| CoverPointIdentifier ":" "coverpoint" Expression "iff" "(" Expression ")" BinsOrEmpty;

rules BinsOrEmpty ::= 
"{" [ AttributeInstance ] [ BinsOrOptionsSemicolon ] "}"
| ";";


rules BinsOrOptions ::= 
CoverageOption 
| BinsKeyword BinIdentifier "=" TransList MaybeIffExpression
| BinsKeyword BinIdentifier "[" "]" "=" TransList MaybeIffExpression
| BinsKeyword BinIdentifier "=" "{" OpenRangeList "}" MaybeIffExpression 
| BinsKeyword BinIdentifier "[" "]" "=" "{" OpenRangeList "}" MaybeIffExpression 
| BinsKeyword BinIdentifier "[" Expression "]" "=" "{" OpenRangeList "}" MaybeIffExpression 
| "wildcard" BinsKeyword BinIdentifier "=" TransList MaybeIffExpression
| "wildcard" BinsKeyword BinIdentifier "[" "]" "=" TransList MaybeIffExpression
| "wildcard" BinsKeyword BinIdentifier "=" "{" OpenRangeList "}" MaybeIffExpression 
| "wildcard" BinsKeyword BinIdentifier "[" "]" "=" "{" OpenRangeList "}" MaybeIffExpression 
| "wildcard" BinsKeyword BinIdentifier "[" Expression "]" "=" "{" OpenRangeList "}" MaybeIffExpression 
| BinsKeyword BinIdentifier "=" "default" MaybeIffExpression 
| BinsKeyword BinIdentifier "[" "]" "=" "default" MaybeIffExpression 
| BinsKeyword BinIdentifier "[" Expression "]" "=" "default" MaybeIffExpression 
| BinsKeyword BinIdentifier "=" "default" "sequence" MaybeIffExpression;

rules BinsKeyword::= "bins" | "illegal_bins" | "ignore_bins";

rules RangeList ::= [ ValueRange ];
rules TransList ::= [ EnclosedTransSetOpen ];
rules TransSet ::= [ TransRangeList ];

rules TransRangeList ::= 
TransItem 
| TransItem "[""*" RepeatRange "]"
| TransItem "[""–>" RepeatRange "]"
| TransItem "[""=" RepeatRange "]";

rules TransItem ::= RangeList ;
RepeatRange ::= 
Expression 
| Expression ":" Expression;

rules CoverCross ::=
"cross" ListOfCoverpoints  SelectBinsOrEmpty
| "cross" ListOfCoverpoints "iff" "(" Expression ")" SelectBinsOrEmpty
| CrossIdentifier ":" "cross" ListOfCoverpoints  SelectBinsOrEmpty
| CrossIdentifier ":" "cross" ListOfCoverpoints "iff" "(" Expression ")" SelectBinsOrEmpty;

rules ListOfCoverpoints ::= CrossItem "," [ CrossItem ];
rules CrossItem ::= CoverPointIdentifier | VariableIdentifier;

rules SelectBinsOrEmpty ::= 
"{" [ BinsSelectionOrOptionSemicolon ] "}"
| ";";

rules BinsSelectionOrOption ::= 
[ AttributeInstance ] CoverageOption 
| [ AttributeInstance ] bins_selection;


rules bins_selection ::= 
BinsKeyword BinIdentifier "=" SelectExpression
| BinsKeyword BinIdentifier "=" SelectExpression "iff" "(" Expression ")" ;

rules SelectExpression ::= 
SelectCondition 
| "!" SelectCondition 
| SelectExpression "&&" SelectExpression 
| SelectExpression "||" SelectExpression 
| "(" SelectExpression ")";

rules SelectCondition ::= 
"binsof" "(" BinsExpression ")" 
"binsof" "(" BinsExpression ")" "intersect" "{" OpenRangeList "}";


rules BinsExpression ::= VariableIdentifier 
| CoverPointIdentifier  
| CoverPointIdentifier "." BinIdentifier;

rules OpenRangeList ::= [ OpenValueRange ];
rules OpenValueRange ::= ValueRange;

rules BinsOrOptionsSemicolon ::= BinsOrOptions ";";
rules BinsSelectionOrOptionSemicolon ::= BinsSelectionOrOption ";";
rules EnclosedTransSetOpen ::= "(" TransSet ")";

rules MaybeIffExpression ::= | "iff" "(" Expression ")";
rules MaybeCoverageEvent ::= | CoverageEvent;
rules MaybeCovergroupIdentifierFooter ::= | ":" CovergroupIdentifier;

separator CoverageSpecOrOption "";
separator BinsOrOptionsSemicolon "";
separator nonempty ValueRange ",";
separator nonempty EnclosedTransSetOpen ",";
separator nonempty TransRangeList "=>";
separator nonempty CrossItem ",";
separator nonempty OpenValueRange ",";


-- A.3 Primitive instances 
-- A.3.1 Primitive instantiation and instances (Done)

rules GateInstantiation ::= 
CmosSwitchtype [CmosSwitchInstance] ";"
| CmosSwitchtype Delay3 [CmosSwitchInstance] ";"
| EnableGatetype [EnableGateInstance] ";"
| EnableGatetype Delay3 [EnableGateInstance] ";"
| EnableGatetype DriveStrength [EnableGateInstance] ";"
| EnableGatetype DriveStrength Delay3 [EnableGateInstance] ";"
| MosSwitchtype [MosSwitchInstance] ";"
| MosSwitchtype Delay3 [MosSwitchInstance] ";"
| NInputGatetype [NInputGateInstance] ";"
| NInputGatetype Delay2 [NInputGateInstance] ";"
| NInputGatetype DriveStrength [NInputGateInstance] ";"
| NInputGatetype DriveStrength Delay2 [NInputGateInstance] ";"
| NOutputGatetype [NOutputGateInstance] ";"
| NOutputGatetype Delay2 [NOutputGateInstance] ";"
| NOutputGatetype DriveStrength [NOutputGateInstance] ";"
| NOutputGatetype DriveStrength Delay2 [NOutputGateInstance] ";"
| PassEnSwitchtype [PassEnableSwitchInstance] ";"
| PassEnSwitchtype Delay2 [PassEnableSwitchInstance] ";"
| PassSwitchtype [PassSwitchInstance] ";"
| "pulldown" [PullGateInstance] ";"
| "pulldown" PulldownStrength [PullGateInstance] ";"
| "pullup" [PullGateInstance] ";"
| "pullup" PullupStrength [PullGateInstance] ";";

rules CmosSwitchInstance ::= MaybeNameOfInstance "(" OutputTerminal "," InputTerminal "," NcontrolTerminal "," PcontrolTerminal ")"
rules EnableGateInstance ::= MaybeNameOfInstance "(" OutputTerminal "," InputTerminal "," EnableTerminal ")"
rules MosSwitchInstance ::= MaybeNameOfInstance "(" OutputTerminal "," InputTerminal "," EnableTerminal ")"
rules NInputGateInstance ::= MaybeNameOfInstance "(" OutputTerminal "," [InputTerminal] ")"
rules NOutputGateInstance ::= MaybeNameOfInstance "(" [OutputTerminal] "," InputTerminal ")"
rules PassSwitchInstance ::= MaybeNameOfInstance "(" InoutTerminal "," InoutTerminal ")"
rules PassEnableSwitchInstance ::= MaybeNameOfInstance "(" InoutTerminal "," InoutTerminal "," EnableTerminal ")"
rules PullGateInstance ::= MaybeNameOfInstance "(" OutputTerminal ")"

rules MaybeNameOfInstance ::= | NameOfInstance;

separator nonempty CmosSwitchInstance ",";
separator nonempty MosSwitchInstance ",";
separator nonempty EnableGateInstance ",";
separator nonempty NInputGateInstance ",";
separator nonempty NOutputGateInstance ",";
separator nonempty PassEnableSwitchInstance ",";
separator nonempty PassSwitchInstance ",";
separator nonempty PullGateInstance ",";

-- A.3.2 Primitive strengths (Done)
rules PulldownStrength ::= 
"(" Strength0 "," Strength1 ")"
| "(" Strength1 "," Strength0 ")"
| "(" Strength0 ")";

rules PullupStrength ::= 
"(" Strength0 "," Strength1 ")"
| "(" Strength1 "," Strength0 ")"
| "(" Strength1 ")";

-- A.3.3 Primitive terminals (Done) 
rules EnableTerminal ::= Expression;
rules InoutTerminal ::= NetLvalue;
rules InputTerminal ::= Expression;
rules NcontrolTerminal ::= Expression;
rules OutputTerminal ::= NetLvalue;
rules PcontrolTerminal ::= Expression;

-- A.3.4 Primitive gate and switch types (Done)
rules CmosSwitchtype ::= "cmos" | "rcmos";
rules EnableGatetype ::= "bufif0" | "bufif1" | "notif0" | "notif1";
rules NInputGatetype ::= "and" | "nand" | "or" | "nor" | "xor" | "xnor";
rules MosSwitchtype ::= "nmos" | "pmos" | "rnmos" | "rpmos";
rules NOutputGatetype ::= "buf" | "not";
rules PassEnSwitchtype ::= "tranif0" | "tranif1" | "rtranif1" | "rtranif0";
rules PassSwitchtype ::= "tran" | "rtran";

-- A.4 Instantiations 
-- A.4.1 Instantiation 
-- A.4.1.1 Module instantiation (Done)

rules ModuleInstantiation ::= ModuleIdentifier MaybeParameterValueAssignment [HierarchicalInstance] ;
rules ParameterValueAssignment ::= "#" "(" MaybeListOfParameterAssignments ")";
rules ListOfParameterAssignments ::= [OrderedParameterAssignment] | [NamedParameterAssignment] ; 

rules OrderedParameterAssignment ::= ParamExpression;
rules NamedParameterAssignment ::= "." ParameterIdentifier "(" MaybeParamExpression ")";
rules HierarchicalInstance ::= NameOfInstance "(" MaybeListOfPortConnections ")";
rules NameOfInstance ::= InstanceIdentifier [UnpackedDimension];

rules ListOfPortConnections ::= [ OrderedPortConnection ] | [ NamedPortConnection ]; 
rules OrderedPortConnection ::= [ AttributeInstance ] MaybeExpression;
rules NamedPortConnection ::= 
[ AttributeInstance ] "." PortIdentifier 
| [ AttributeInstance ] "." PortIdentifier "(" MaybeExpression ")" 
| [ AttributeInstance ] ".*";


rules MaybeExpression ::= | Expression;
rules MaybeListOfPortConnections ::= | ListOfPortConnections;
rules MaybeParamExpression ::= | ParamExpression;
rules MaybeParameterValueAssignment ::= | ParameterValueAssignment;
rules MaybeListOfParameterAssignments ::= | ListOfParameterAssignments;

separator nonempty OrderedPortConnection ",";
separator nonempty NamedPortConnection ",";
separator nonempty OrderedParameterAssignment ",";
separator nonempty NamedParameterAssignment ",";


-- A.4.1.2 Interface instantiation (Done)
rules InterfaceInstantiation ::= 
InterfaceIdentifier [HierarchicalInstance] |
InterfaceIdentifier ParameterValueAssignment [HierarchicalInstance] ;


-- A.4.1.3 Program instantiation (Done)
rules ProgramInstantiation ::= 
ProgramIdentifier [HierarchicalInstance] |
ProgramIdentifier ParameterValueAssignment [HierarchicalInstance] ;

-- A.4.1.4 Checker instantiation (Done) 
rules CheckerInstantiation ::= CheckerIdentifier NameOfInstance "(" MaybeListOfCheckerPortConnections ")" ";";
rules ListOfCheckerPortConnections ::= [OrderedCheckerPortConnection] | [NamedCheckerPortConnection];
rules OrderedCheckerPortConnection ::= [ AttributeInstance ] MaybePropertyActualArg;

rules NamedCheckerPortConnection ::=
[ AttributeInstance ] "." PortIdentifier
| [ AttributeInstance ] "." PortIdentifier "(" MaybePropertyActualArg ")"
| [ AttributeInstance ] ".*";

rules MaybeListOfCheckerPortConnections ::= | ListOfCheckerPortConnections;
rules MaybePropertyActualArg ::= | PropertyActualArg;
separator nonempty OrderedCheckerPortConnection ",";
separator nonempty NamedCheckerPortConnection ",";

-- A.4.2 Generated instantiation (Done)

rules GenerateRegion ::= "generate" [ GenerateItem ] "endgenerate";
rules LoopGenerateConstruct ::= "for" "(" GenvarInitialization ";" GenvarExpression ";" GenvarIteration ")" GenerateBlock;
rules GenvarInitialization ::= MaybeGenvar GenvarIdentifier "=" ConstantExpression;
rules GenvarIteration ::= 
GenvarIdentifier AssignmentOperator GenvarExpression 
| IncOrDecOperator GenvarIdentifier 
| GenvarIdentifier IncOrDecOperator;

rules ConditionalGenerateConstruct ::= IfGenerateConstruct | CaseGenerateConstruct ;
rules IfGenerateConstruct ::= "if" "(" ConstantExpression ")" GenerateBlock MaybeElseGenerateBlock;

rules CaseGenerateConstruct ::= "case" "(" ConstantExpression ")" [ CaseGenerateItem ] "endcase"
rules CaseGenerateItem ::= [ConstantExpression] ":" GenerateBlock | "default" GenerateBlock | "default" ":" GenerateBlock ;

rules GenerateBlock ::= GenerateItem 
| MaybeGenerateBlockIdentifierHeader begin MaybeGenerateBlockIdentifierFooter [ GenerateItem ] "end" MaybeGenerateBlockIdentifierFooter;

rules GenerateItem ::= 
ModuleOrGenerateItem 
| InterfaceOrGenerateItem 
| CheckerOrGenerateItem;

rules MaybeGenvar ::= | genvar;
rules MaybeElseGenerateBlock ::= | "else" GenerateBlock;
rules MaybeGenerateBlockIdentifierFooter ::= | ":" GenerateBlockIdentifier;
rules MaybeGenerateBlockIdentifierHeader ::= | GenerateBlockIdentifier ":";

separator nonempty ConstantExpression ",";
separator CaseGenerateItem "";
separator GenerateItem "";

-- A.5 UDP declaration and instantiation 
-- A.5.1 UDP declaration
-- A.5.2 UDP ports 
-- A.5.3 UDP body (Done)
rules UdpBody ::= CombinationalBody | SequentialBody ;
rules CombinationalBody ::= "table" [CombinationalEntry] "endtable";
rules CombinationalEntry ::= LevelInputList ":" OutputSymbol ";";
rules SequentialBody ::= "table" [SequentialEntry] "endtable" | UdpInitialStatement "table" [SequentialEntry] "endtable";
rules UdpInitialStatement ::= "initial" OutputPortIdentifier "=" InitVal ";";
rules InitVal ::= "1'b0" | "1'b1" | "1'bx" | "1'bX" | "1'B0" | "1'B1" | "1'Bx" | "1'BX" | "1" | "0";
rules SequentialEntry ::= SeqInputList ":" CurrentState ":" NextState ";";
rules SeqInputList ::= LevelInputList | EdgeInputList ;
rules LevelInputList ::= LevelSymbol [LevelSymbol];
rules EdgeInputList ::= [LevelSymbol] EdgeIndicator [LevelSymbol] ;
rules EdgeIndicator ::= "(" LevelSymbol LevelSymbol ")" | EdgeSymbol ;
rules CurrentState ::= LevelSymbol ;
rules NextState ::= OutputSymbol | "-";
rules OutputSymbol ::= "0" | "1" | "x" | "X";
rules LevelSymbol ::= "0" | "1" | "x" | "X" | "?" | "b" | "B";
rules EdgeSymbol ::= "r" | "R" | "f" | "F" | "p" | "P" | "n" | "N" | "*";

separator LevelSymbol "";
separator nonempty SequentialEntry "";
separator nonempty CombinationalEntry "";

-- A.5.4 UDP instantiation (Done)
rules UdpInstantiation ::= 
UdpIdentifier [ UdpInstance ] ";" |
UdpIdentifier Delay2 [ UdpInstance ] ";" |
UdpIdentifier DriveStrength [ UdpInstance ] ";" |
UdpIdentifier DriveStrength Delay2 [ UdpInstance ] ";";
rules UdpInstance ::= "(" OutputTerminal "," [InputTerminal] ")" | NameOfInstance "(" OutputTerminal "," [InputTerminal] ")";

separator nonempty UdpInstance ",";
separator nonempty InputTerminal ",";
separator nonempty OutputTerminal ",";

-- A.6 Behavioral statements 
-- A.6.1 Continuous assignment and net alias statements (Done)
rules ContinuousAssign ::= 
"assign" ListOfNetAssignments ";" | 
"assign" Delay3 ListOfNetAssignments ";" | 
"assign" DriveStrength ListOfNetAssignments ";" | 
"assign" DriveStrength Delay3 ListOfNetAssignments ";" | 
"assign" ListOfVariableAssignments ";" |
"assign" DelayControl ListOfVariableAssignments ";";

rules ListOfNetAssignments ::= [NetAssignment];
rules ListOfVariableAssignments ::= [VariableAssignment];

rules NetAlias ::= "alias" NetLvalue "=" NetLvalue RepeatEqualNetLvalue ";" | 

rules RepeatEqualNetLvalue ::= | "=" NetLvalue | "=" NetLvalue RepeatEqualNetLvalue;

rules NetAssignment ::= NetLvalue "=" Expression;

separator nonempty NetAssignment ",";
separator nonempty VariableAssignment ",";

-- A.6.2 Procedural blocks and assignments (Done)
rules InitialConstruct ::= "initial" StatementOrNull ;
rules AlwaysConstruct ::= AlwaysKeyword Statement ;
rules AlwaysKeyword ::= "always" | "always_comb" | "always_latch" | "always_ff" ;
rules FinalConstruct ::= "final" FunctionStatement ;
rules BlockingAssignment ::= 
VariableLvalue "=" DelayOrEventControl Expression 
| NonrangeVariableLvalue "=" DynamicArrayNew 
| HierarchicalVariableIdentifier 
| ImplicitClassHandle "." HierarchicalVariableIdentifier 
| ClassScope HierarchicalVariableIdentifier 
| PackageScope HierarchicalVariableIdentifier 
Select "=" ClassNew 
| OperatorAssignment ;

rules OperatorAssignment ::= VariableLvalue AssignmentOperator Expression ; 
rules AssignmentOperator ::= "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" | "<<=" | ">>=" | "<<<=" | ">>>=";
rules NonblockingAssignment ::= VariableLvalue "<=" DelayOrEventControl Expression | VariableLvalue "<=" Expression ;

rules ProceduralContinuousAssignment ::= 
"assign" VariableAssignment 
| "deassign" VariableLvalue 
| "force" VariableAssignment 
| "force" NetAssignment 
| "release" VariableLvalue 
| "release" NetLvalue ;

rules VariableAssignment ::= VariableLvalue "=" Expression;

-- A.6.3 Parallel and sequential blocks (Done)
rules ActionBlock ::= StatementOrNull | MaybeStatement "else" StatementOrNull ;
rules SeqBlock ::= 
"begin" MaybeBlockIdentifierFooter [ BlockItemDeclaration ] [ StatementOrNull ] 
"end" MaybeBlockIdentifierFooter ;

rules ParBlock ::= 
"fork" MaybeBlockIdentifierFooter [ BlockItemDeclaration ] [ StatementOrNull ] JoinKeyword MaybeBlockIdentifierFooter;

rules JoinKeyword ::= "join" | "join_any" | "join_none";

rules MaybeStatement ::= | Statement;
rules MaybeBlockIdentifierFooter ::= | ":" BlockIdentifier;

-- A.6.4 Statements (Done)
rules StatementOrNull ::= Statement | [ AttributeInstance ] ";";
rules Statement ::= [ AttributeInstance ] StatementItem | BlockIdentifier ":" [ AttributeInstance ] StatementItem ;

StatementItem ::= 
BlockingAssignment ";"
| NonblockingAssignment ";"
| ProceduralContinuousAssignment ";"
| CaseStatement 
| ConditionalStatement 
| IncOrDecExpression ";"
| SubroutineCallStatement 
| DisableStatement 
| EventTrigger 
| LoopStatement 
| JumpStatement 
| ParBlock 
| ProceduralTimingControlStatement 
| SeqBlock 
| WaitStatement 
| ProceduralAssertionStatement 
| ClockingDrive ";"
| RandsequenceStatement 
| RandcaseStatement 
| ExpectPropertyStatement ;

rules FunctionStatement ::= Statement ; 
rules FunctionStatementOrNull ::= FunctionStatement | [ AttributeInstance ] ";";
rules VariableIdentifierList ::= [VariableIdentifier];

separator nonempty VariableIdentifier ",";

-- A.6.5 Timing control statements (Done)
rules ProceduralTimingControlStatement ::= ProceduralTimingControl StatementOrNull;
rules DelayOrEventControl ::= DelayControl | EventControl | "repeat" "(" Expression ")" EventControl;
rules DelayControl ::= "#" DelayValue | "#" "(" MintypmaxExpression ")";
rules EventControl ::= 
"@" HierarchicalEventIdentifier 
| "@" "(" EventExpression ")"
| "@""*"
| "@" "(*)"
| "@" PsOrHierarchicalSequenceIdentifier;

rules EventExpression ::= 
Expression MaybeIffExpression
| EdgeIdentifier Expression MaybeIffExpression
| SequenceInstance MaybeIffExpression 
| EventExpression "or" EventExpression 
| EventExpression "," EventExpression 
| "(" EventExpression ")";

rules ProceduralTimingControl ::= DelayControl | EventControl | CycleDelay;

rules JumpStatement ::= "return" MaybeExpression ";" | "break" ";" | "continue" ";";

rules WaitStatement ::= 
"wait" "(" Expression ")" StatementOrNull 
| "wait" "fork" ";"
| "wait_order" "(" [HierarchicalIdentifier] ")" ActionBlock;

rules EventTrigger ::= 
"->" HierarchicalEventIdentifier ";"
|"->>" HierarchicalEventIdentifier ";"
|"->>" DelayOrEventControl HierarchicalEventIdentifier ";";

rules DisableStatement ::= 
"disable" HierarchicalTaskIdentifier ";"
| "disable" HierarchicalBlockIdentifier ";"
| "disable" "fork" ";"

rules MaybeIffExpression ::= | "iff" Expression;

-- A.6.6 Conditional statements (Done)
rules ConditionalStatement ::= 
"if" "(" CondPredicate ")" StatementOrNull [ ElseIfBlock ] MaybeElseStatementOrNull 
| UniquePriority "if" "(" CondPredicate ")" StatementOrNull [ ElseIfBlock ] MaybeElseStatementOrNull;

rules UniquePriority ::= "unique" | "unique0" | "priority";
rules CondPredicate ::= [ExpressionOrCondPattern]; 
rules ExpressionOrCondPattern ::= Expression | CondPattern; 
rules CondPattern ::= Expression "matches" pattern;

rules MaybeElseStatementOrNull ::= | "else" StatementOrNull;
rules ElseIfBlock ::= "else" "if" "(" CondPredicate ")" StatementOrNull;

separator ElseIfBlock "";
separator nonempty ExpressionOrCondPattern "&&&";

-- A.6.7 Case statements (Done)
rules CaseStatement ::= 
MaybeUniquePriority CaseKeyword "(" CaseExpression ")" [ CaseItem ] "endcase"
| MaybeUniquePriority CaseKeyword "("CaseExpression ")" "matches" [ CasePatternItem ] "endcase"
| MaybeUniquePriority "case" "(" CaseExpression ")" "inside" [ CaseInsideItem ] "endcase";

rules CaseKeyword ::= "case" | "casez" | "casex";
rules CaseExpression ::= Expression;

rules CaseItem ::= 
[ CaseItemExpression ] ":" StatementOrNull 
| "default" StatementOrNull
| "default" ":" StatementOrNull;

rules CasePatternItem ::= 
pattern ":" StatementOrNull 
| pattern "&&&" Expression ":" StatementOrNull 
| "default" StatementOrNull
| "default" ":" StatementOrNull;

rules CaseInsideItem ::= 
OpenRangeList ":" StatementOrNull 
| "default" StatementOrNull
| "default" ":" StatementOrNull;

rules CaseItemExpression ::= Expression ;

rules RandcaseStatement ::= "randcase" [ RandcaseItem ] "endcase";
rules RandcaseItem ::= Expression ":" StatementOrNull ;

rules MaybeUniquePriority ::= | UniquePriority;

separator nonempty CaseItem "";
separator nonempty CaseInsideItem "";
separator nonempty CasePatternItem "";
separator nonempty RandcaseItem "";
separator nonempty CaseItemExpression ",";


-- A.6.7.1 Patterns 
-- A.6.8 Looping statements (Done)
rules LoopStatement ::= 
forever StatementOrNull 
| "repeat" "(" Expression ")" StatementOrNull 
| "while" "(" Expression ")" StatementOrNull 
| "for" "(" ForInitialization ";" Expression ";" ForStep ")" 
StatementOrNull 
| "do" StatementOrNull "while" "(" Expression ")" ";"
| "foreach" "(" PsOrHierarchicalArrayIdentifier "[" LoopVariables "]" ")" Statement;

rules ForInitialization ::= ListOfVariableAssignments | [ForVariableDeclaration];
rules ForVariableDeclaration ::= DataType VariableIdentifier "=" Expression [VariableAssignmentCont]; 

rules ForStep ::= [ForStepAssignment];
rules ForStepAssignment ::= OperatorAssignment | IncOrDecExpression | FunctionSubroutineCall ;
rules LoopVariables ::= [MaybeIndexVariableIdentifier];

rules VariableAssignmentCont ::= "," VariableIdentifier "=" Expression; 
rules MaybeIndexVariableIdentifier ::= | IndexVariableIdentifier;

separator nonempty ForVariableDeclaration ",";
separator VariableAssignmentCont "";
separator nonempty ForStepAssignment ",";
separator nonempty MaybeIndexVariableIdentifier ",";

-- A.6.9 Subroutine call statements (Done)
rules SubroutineCallStatement ::= SubroutineCall ";" | "void" "'" "(" FunctionSubroutineCall ")" ;

-- A.6.10 Assertion statements (Done)

rules AssertionItem ::= 
ConcurrentAssertionItem 
| DeferredImmediateAssertionItem;

rules DeferredImmediateAssertionItem ::= MaybeBlockIdentifierHeader DeferredImmediateAssertionStatement;

rules ProceduralAssertionStatement ::= 
ConcurrentAssertionStatement 
| ImmediateAssertionStatement 
| CheckerInstantiation;

rules ImmediateAssertionStatement ::= 
SimpleImmediateAssertionStatement 
| DeferredImmediateAssertionStatement;

rules SimpleImmediateAssertionStatement ::= 
SimpleImmediateAssertStatement 
| SimpleImmediateAssumeStatement 
| SimpleImmediateCoverStatement;

rules SimpleImmediateAssertStatement ::= 
"assert" "(" Expression ")" ActionBlock ;
rules SimpleImmediateAssumeStatement ::= 
"assume" "(" Expression ")" ActionBlock ;

rules SimpleImmediateCoverStatement ::= 
"cover" "(" Expression ")" StatementOrNull ;

rules DeferredImmediateAssertionStatement ::= 
DeferredImmediateAssertStatement 
| DeferredImmediateAssumeStatement 
| DeferredImmediateCoverStatement ;

rules DeferredImmediateAssertStatement ::= 
"assert" "#0" "(" Expression ")" ActionBlock ;
rules DeferredImmediateAssumeStatement ::= 
"assume" "#0" "(" Expression ")" ActionBlock ;
rules DeferredImmediateCoverStatement ::= 
"cover" "#0" "(" Expression ")" StatementOrNull ;

rules MaybeBlockIdentifierHeader ::= | BlockIdentifier ":" ;

-- A.6.11 Clocking block (Done)
rules ClockingDeclaration ::= 
MaybeDefault "clocking" MaybeClockingIdentifier ClockingEvent ";" [ ClockingItem ] "endclocking" MaybeClockingIdentifierFooter
| "global" "clocking" MaybeClockingIdentifier ClockingEvent ";" "endclocking" MaybeClockingIdentifierFooter;

rules ClockingEvent ::= 
"@" Ident 
| "@" "(" EventExpression ")"

rules ClockingItem ::= 
"default" DefaultSkew ";"
| ClockingDirection ListOfClockingDeclAssign ";"
| [ AttributeInstance ] AssertionItemDeclaration;

rules DefaultSkew ::= 
"input" ClockingSkew 
| "output" ClockingSkew 
| "input" ClockingSkew output ClockingSkew;

rules ClockingDirection ::= 
"input" MaybeClockingSkew 
| "output" MaybeClockingSkew 
| "input" MaybeClockingSkew "output" MaybeClockingSkew 
| "inout";

rules ListOfClockingDeclAssign ::= [ ClockingDeclAssign ] ;
rules ClockingDeclAssign ::= SignalIdentifier MaybeAssignExpression; 

rules ClockingSkew ::= EdgeIdentifier | EdgeIdentifier DelayControl | DelayControl 
rules ClockingDrive ::= ClockvarExpression "<=" Expression | ClockvarExpression "<=" CycleDelay Expression;

rules CycleDelay ::= 
"##" IntegralNumber 
| "##" Ident 
| "##" "(" Expression ")";

rules Clockvar ::= HierarchicalIdentifier ;
rules ClockvarExpression ::= Clockvar Select ;


rules MaybeDefault ::= | "default";
rules MaybeClockingIdentifier ::= | ClockingIdentifier;
rules MaybeClockingIdentifierFooter ::= | ":" ClockingIdentifier;
rules MaybeClockingSkew ::= | ClockingSkew;


separator ClockingItem "";
separator nonempty ClockingDeclAssign ",";
-- A.6.12 Randsequence (Done)

rules RandsequenceStatement ::= "randsequence" "(" MaybeProductionIdentifier ")" [ Production ] "endsequence";

rules Production ::= MaybeDataTypeOrVoid ProductionIdentifier MaybeEnclosedTfPortList ":" [RsRule] ";";

rules RsRule ::= 
RsProductionList 
| RsProductionList ":=" WeightSpecification 
| RsProductionList ":=" WeightSpecification RsCodeBlock ;

rules RsProductionList ::= 
[ RsProd ]
| "rand" "join" MaybeEnclosedExpression ProductionItem [ ProductionItem ];

rules WeightSpecification ::= 
IntegralNumber 
| PsIdentifier 
| "(" Expression ")";

rules RsCodeBlock ::= "{" [ DataDeclaration ] [ StatementOrNull ] "}"
rules RsProd ::= 
ProductionItem 
| RsCodeBlock 
| RsIfElse 
| RsRepeat 
| RsCase;

rules ProductionItem ::= ProductionIdentifier | ProductionIdentifier "(" ListOfArguments ")";
rules RsIfElse ::= "if" "(" Expression ")" ProductionItem | "if" "(" Expression ")" ProductionItem "else" ProductionItem;
rules RsRepeat ::= "repeat" "(" Expression ")" ProductionItem ;
rules RsCase ::= "case" "(" CaseExpression ")" [ RsCaseItem ] "endcase"
rules RsCaseItem ::= 
[ CaseItemExpression ] ":" ProductionItem ";"
| "default" ProductionItem ";"
| "default" ":" ProductionItem ";"

rules MaybeProductionIdentifier ::= | ProductionIdentifier;
rules MaybeEnclosedTfPortList ::= | "(" TfPortList ")";
rules MaybeDataTypeOrVoid ::= | DataTypeOrVoid;

separator nonempty Production "";
separator nonempty ProductionItem "";
separator nonempty RsProd "";
separator nonempty RsCaseItem "";
separator nonempty CaseItemExpression ",";

separator DataDeclaration "";
separator StatementOrNull "";

separator nonempty RsRule "|";

-- A.7 Specify section 
-- A.7.1 Specify block declaration (Done)

rules SpecifyBlock ::= "specify" [ SpecifyItem ] "endspecify";

rules SpecifyItem ::= 
SpecparamDeclaration 
| PulsestyleDeclaration 
| ShowcancelledDeclaration 
| PathDeclaration;
--| system_timing_check ;

rules PulsestyleDeclaration ::= 
"pulsestyle_onevent" ListOfPathOutputs ";"
| "pulsestyle_ondetect" ListOfPathOutputs ";";

rules ShowcancelledDeclaration ::= 
"showcancelled" ListOfPathOutputs ";"
| "noshowcancelled" ListOfPathOutputs ";";

separator SpecifyItem "";

-- A.7.2 Specify path declarations (Done)

rules PathDeclaration ::= 
SimplePathDeclaration ";"
| EdgeSensitivePathDeclaration ";"
| StateDependentPathDeclaration ";";

rules SimplePathDeclaration ::= 
ParallelPathDescription "=" PathDelayValue 
| FullPathDescription "=" PathDelayValue ;

rules ParallelPathDescription ::= 
"(" SpecifyInputTerminalDescriptor "=>" SpecifyOutputTerminalDescriptor ")"
| "(" SpecifyInputTerminalDescriptor PolarityOperator "=>" SpecifyOutputTerminalDescriptor ")";

rules FullPathDescription ::= 
"(" ListOfPathInputs "*>" ListOfPathOutputs ")"
| "(" ListOfPathInputs PolarityOperator "*>" ListOfPathOutputs ")";

rules ListOfPathInputs ::= [SpecifyInputTerminalDescriptor];
rules ListOfPathOutputs ::= [SpecifyOutputTerminalDescriptor];

separator nonempty SpecifyInputTerminalDescriptor ",";
separator nonempty SpecifyOutputTerminalDescriptor ",";

-- A.7.3 Specify block terminals (Done)
rules SpecifyInputTerminalDescriptor ::= InputIdentifier | InputIdentifier "[" ConstantRangeExpression "]";
rules SpecifyOutputTerminalDescriptor ::= OutputIdentifier | OutputIdentifier "[" ConstantRangeExpression "]"; 
rules InputIdentifier ::= InputPortIdentifier | InoutPortIdentifier | InterfaceIdentifier"."PortIdentifier;
rules OutputIdentifier ::= OutputPortIdentifier | InoutPortIdentifier | InterfaceIdentifier"."PortIdentifier;


-- A.7.4 Specify path delays (Done)

rules PathDelayValue ::= 
ListOfPathDelayExpressions 
| "(" ListOfPathDelayExpressions ")";

rules ListOfPathDelayExpressions ::= 
TPathDelayExpression 
| TrisePathDelayExpression "," TfallPathDelayExpression 
| TrisePathDelayExpression "," TfallPathDelayExpression "," TzPathDelayExpression 
| T01PathDelayExpression "," T10PathDelayExpression "," T0zPathDelayExpression ","
Tz1PathDelayExpression "," T1zPathDelayExpression "," Tz0PathDelayExpression 
| T01PathDelayExpression "," T10PathDelayExpression "," T0zPathDelayExpression "," 
Tz1PathDelayExpression "," T1zPathDelayExpression "," Tz0PathDelayExpression ","
T0xPathDelayExpression "," Tx1PathDelayExpression "," T1xPathDelayExpression ","
Tx0PathDelayExpression "," TxzPathDelayExpression "," TzxPathDelayExpression;

rules TPathDelayExpression ::= PathDelayExpression ;
rules TrisePathDelayExpression ::= PathDelayExpression ;
rules TfallPathDelayExpression ::= PathDelayExpression ;
rules TzPathDelayExpression ::= PathDelayExpression ;
rules T01PathDelayExpression ::= PathDelayExpression ;
rules T10PathDelayExpression ::= PathDelayExpression ;

rules T0zPathDelayExpression ::= PathDelayExpression ;
rules Tz1PathDelayExpression ::= PathDelayExpression ;
rules T1zPathDelayExpression ::= PathDelayExpression ;
rules Tz0PathDelayExpression ::= PathDelayExpression ;
rules T0xPathDelayExpression ::= PathDelayExpression ;
rules Tx1PathDelayExpression ::= PathDelayExpression ;
rules T1xPathDelayExpression ::= PathDelayExpression ;
rules Tx0PathDelayExpression ::= PathDelayExpression ;
rules TxzPathDelayExpression ::= PathDelayExpression ;
rules TzxPathDelayExpression ::= PathDelayExpression;

rules PathDelayExpression ::= ConstantMintypmaxExpression ;

rules EdgeSensitivePathDeclaration ::= 
ParallelEdgeSensitivePathDescription "=" PathDelayValue 
| FullEdgeSensitivePathDescription "=" PathDelayValue;

rules ParallelEdgeSensitivePathDescription ::= 
"(" MaybeEdgeIdentifier SpecifyInputTerminalDescriptor MaybePolarityOperator "=>"
"(" SpecifyOutputTerminalDescriptor MaybePolarityOperator ":" DataSourceExpression ")" ")"
rules FullEdgeSensitivePathDescription ::= 
"(" MaybeEdgeIdentifier ListOfPathInputs MaybePolarityOperator "*>"
"(" ListOfPathOutputs MaybePolarityOperator ":" DataSourceExpression ")" ")"

rules DataSourceExpression ::= Expression;
rules EdgeIdentifier ::= "posedge" | "negedge" | "edge";

rules StateDependentPathDeclaration ::= 
"if" "(" ModulePathExpression ")" SimplePathDeclaration 
| "if" "(" ModulePathExpression ")" EdgeSensitivePathDeclaration 
| "ifnone" SimplePathDeclaration;

rules PolarityOperator ::= "+" | "-";

rules MaybePolarityOperator ::= | PolarityOperator;
rules MaybeEdgeIdentifier ::= | EdgeIdentifier;

-- A.7.5 System timing checks 
-- A.7.5.1 System timing check commands (TODO)
-- A.7.5.2 System timing check command arguments(TODO) 
-- A.7.5.3 System timing check event definitions(TODO)

token ZOrX ('x' | 'X' | 'z' | 'Z');

-- A.8 Expressions 
-- A.8.1 Concatenations (Done)
rules Concatenation ::= "{" [Expression] "}";
rules ConstantConcatenation ::= "{" [ConstantExpression] "}";
rules ConstantMultipleConcatenation ::= "{" ConstantExpression ConstantConcatenation "}" ;
rules ModulePathConcatenation ::= "{" [ModulePathExpression] "}" ;
rules ModulePathMultipleConcatenation ::= "{" ConstantExpression ModulePathConcatenation "}" ;
rules MultipleConcatenation ::= "{" Expression Concatenation "}" ;
rules StreamingConcatenation ::= "{" StreamOperator SliceSize StreamConcatenation "}" | "{" StreamOperator StreamConcatenation "}" ;
rules StreamOperator ::= ">>" | "<<" ;
rules SliceSize ::= SimpleType | ConstantExpression;
rules StreamConcatenation ::= "{" [StreamExpression] "}";
rules StreamExpression ::= Expression | Expression "with" "[" ArrayRangeExpression "]";
rules ArrayRangeExpression ::= 
Expression 
| Expression ":" Expression 
| Expression "+:" Expression 
| Expression "-:" Expression ;
rules EmptyQueue ::= "{" "}" ;

separator nonempty Expression ",";
separator nonempty ConstantExpression ",";
separator nonempty ModulePathExpression ",";
separator nonempty StreamExpression ",";


-- A.8.2 Subroutine calls (Done)

rules ConstantFunctionCall ::= FunctionSubroutineCall;
rules TfCall ::= 
PsOrHierarchicalTfIdentifier [ AttributeInstance ] 
| PsOrHierarchicalTfIdentifier [ AttributeInstance ] "(" ListOfArguments ")"

rules SystemTfCall ::= 
SystemTfIdentifier 
| SystemTfIdentifier "(" ListOfArguments ")"
| SystemTfIdentifier "(" DataType ")"
| SystemTfIdentifier "(" DataType "," Expression ")";

rules FunctionSubroutineCall ::= SubroutineCall ;

rules ListOfArguments ::= 
[ MaybeExpression ] [IdentiferContWithComma] 
| "." Ident "(" MaybeExpression ")" [IdentiferContWithComma];

rules SubroutineCall ::= 
TfCall 
| SystemTfCall 
| MethodCall 
| RandomizeCall
| "std::" RandomizeCall;

rules MethodCall ::= MethodCallRoot "." MethodCallBody 
rules MethodCallBody ::= 
MethodIdentifier [ AttributeInstance ] 
| MethodIdentifier [ AttributeInstance ] "(" ListOfArguments ")" 
| BuiltInMethodCall ;

rules BuiltInMethodCall ::= 
ArrayManipulationCall 
| RandomizeCall ;

rules ArrayManipulationCall ::= 
ArrayMethodName [ AttributeInstance ] 
| ArrayMethodName [ AttributeInstance ] "with" "(" Expression ")"  
| ArrayMethodName [ AttributeInstance ] "(" ListOfArguments ")"   
| ArrayMethodName [ AttributeInstance ] "(" ListOfArguments ")" "with" "(" Expression ")" ;

rules RandomizeCall ::= 
"randomize" [ AttributeInstance ] 
| "randomize" [ AttributeInstance ] "with" ConstraintBlock
| "randomize" [ AttributeInstance ] "with" "(" MaybeIdentifierList ")" ConstraintBlock
| "randomize" [ AttributeInstance ] "(" MaybeVariableIdentifierList ")" 
| "randomize" [ AttributeInstance ] "(" MaybeVariableIdentifierList ")" "with" ConstraintBlock
| "randomize" [ AttributeInstance ] "(" MaybeVariableIdentifierList ")" "with" "(" MaybeIdentifierList ")" ConstraintBlock;

rules MethodCallRoot ::= Primary | ImplicitClassHandle ;
rules ArrayMethodName ::= MethodIdentifier | "unique" | "and" | "or" | "xor";

rules IdentiferContWithComma ::= "," "." Ident "(" MaybeExpression ")"

rules MaybeVariableIdentifierList ::= | VariableIdentifierList | "null";
rules MaybeIdentifierList ::= | IdentifierList;

seperator nonempty MaybeExpression ",";
seperator IdentiferContWithComma "";

-- A.8.3 Expressions (Done)
rules IncOrDecExpression ::= 
IncOrDecOperator [ AttributeInstance ] VariableLvalue 
| VariableLvalue [ AttributeInstance ] IncOrDecOperator ;
rules ConditionalExpression ::= CondPredicate "?" [ AttributeInstance ] Expression ":" Expression ;

rules ConstantExpression ::= 
ConstantPrimary 
| UnaryOperator [ AttributeInstance ] ConstantPrimary 
| ConstantExpression BinaryOperator [ AttributeInstance ] ConstantExpression 
| ConstantExpression "?" [ AttributeInstance ] ConstantExpression ":" ConstantExpression ;

rules ConstantMintypmaxExpression ::= 
ConstantExpression 
| ConstantExpression ":" ConstantExpression ":" ConstantExpression ;

rules ConstantParamExpression ::= ConstantMintypmaxExpression | DataType | "$" ;
rules ParamExpression ::= MintypmaxExpression | DataType;

rules ConstantRangeExpression ::= ConstantExpression | ConstantPartSelectRange ;
rules ConstantPartSelectRange ::= ConstantRange | ConstantIndexedRange ;

rules ConstantRange ::= ConstantExpression ":" ConstantExpression ;
rules ConstantIndexedRange ::= 
ConstantExpression "+:" ConstantExpression 
| ConstantExpression "-:" ConstantExpression;

rules Expression ::= 
ConstantPrimary
| UnaryOperator [ AttributeInstance ] ConstantPrimary 
| IncOrDecExpression 
| "(" OperatorAssignment ")"
| Expression BinaryOperator [ AttributeInstance ] Expression 
| ConditionalExpression 
| InsideExpression 
| TaggedUnionExpression ;

rules TaggedUnionExpression ::= "tagged" MemberIdentifier MaybeExpression;

rules InsideExpression ::= Expression "inside" [OpenRangeList];
rules ValueRange ::= Expression | "[" Expression ":" Expression "]";

rules MintypmaxExpression ::= Expression | Expression ":" Expression ":" Expression ;
rules ModulePathConditionalExpression ::= ModulePathExpression "?" [ AttributeInstance ] ModulePathExpression ":" ModulePathExpression ;

rules ModulePathExpression ::= 
ModulePathPrimary 
| UnaryModulePathOperator [ AttributeInstance ] ModulePathPrimary 
| ModulePathExpression BinaryModulePathOperator [ AttributeInstance ] 
ModulePathExpression 
| ModulePathConditionalExpression 
rules ModulePathMintypmaxExpression ::= 
ModulePathExpression 
| ModulePathExpression ":" ModulePathExpression ":" ModulePathExpression;

rules PartSelectRange ::= ConstantRange | IndexedRange ; 
rules IndexedRange ::= Expression "+:" ConstantExpression | Expression "-:" ConstantExpression ; 
rules GenvarExpression ::= ConstantExpression; 

separator OpenRangeList "";

-- A.8.4 Primaries (Done)
rules ConstantPrimary ::= 
PrimaryLiteral 
| PsParameterIdentifier ConstantSelect 
| SpecparamIdentifier 
| SpecparamIdentifier "[" ConstantRangeExpression "]" 
| GenvarIdentifier
| EnumIdentifier 
| ClassScope EnumIdentifier 
| PackageScope EnumIdentifier 
| ConstantConcatenation  
| ConstantConcatenation "[" ConstantRangeExpression "]" 
| ConstantMultipleConcatenation 
| ConstantMultipleConcatenation "[" ConstantRangeExpression "]" 
| ConstantFunctionCall 
| ConstantLetExpression 
| "(" ConstantMintypmaxExpression ")"
| ConstantCast 
| ConstantAssignmentPatternExpression 
| TypeReference;

rules ModulePathPrimary ::= 
Number 
| Ident 
| ModulePathConcatenation 
| ModulePathMultipleConcatenation 
| FunctionSubroutineCall 
| "(" ModulePathMintypmaxExpression ")";

rules Primary ::= 
PrimaryLiteral 
| HierarchicalIdentifier Select 
| PackageScope HierarchicalIdentifier Select 
| ClassQualifier HierarchicalIdentifier Select 
| EmptyQueue 
| Concatenation 
| Concatenation "[" RangeExpression "]" 
| MultipleConcatenation  
| MultipleConcatenation "[" RangeExpression "]" 
| FunctionSubroutineCall 
| LetExpression 
| "(" MintypmaxExpression ")"
| Cast 
| AssignmentPatternExpression 
| StreamingConcatenation 
| SequenceMethodCall 
| "this"
| "$"
| "null";

rules ClassQualifier ::= 
| ClassScope  
| ImplicitClassHandle "."
| "local::"  
| "local::" ClassScope  
| "local::" ImplicitClassHandle ".";

rules RangeExpression ::= Expression | PartSelectRange; 
rules PrimaryLiteral ::= Number | TimeLiteral | UnbasedUnsizedLiteral | StringLiteral;

rules TimeLiteral ::= UnsignedNumber TimeUnit | FixedPointNumber TimeUnit;
rules TimeUnit ::= "s" | "ms" | "us" | "ns" | "ps" | "fs";

rules ImplicitClassHandle ::= "this" | "super" | "this" "." "super";

rules BitSelect ::= [EnclosedExpressionSquare];

rules Select ::= 
BitSelect 
| BitSelect  "[" PartSelectRange "]"  
| [MemberBitSelect] MemberBitSelect
| [MemberBitSelect] MemberBitSelect  "[" PartSelectRange "]"  

rules NonrangeSelect ::= BitSelect | [MemberBitSelect] MemberBitSelect;

rules ConstantBitSelect ::= [EnclosedConstantExpressionSquare];

rules ConstantSelect ::= 
ConstantBitSelect
| ConstantBitSelect "[" ConstantPartSelectRange "]" 
| "." MemberIdentifier ConstantBitSelect
| "." MemberIdentifier ConstantBitSelect "[" ConstantPartSelectRange "]" 
| MemberConstantBitSelect "." MemberIdentifier ConstantBitSelect
| MemberConstantBitSelect "." MemberIdentifier ConstantBitSelect "[" ConstantPartSelectRange "]" ;


rules ConstantCast ::= CastingType "'" "(" ConstantExpression ")";
rules ConstantLetExpression ::= LetExpression;
rules Cast ::= CastingType "'" "(" Expression ")";

rules EnclosedConstantExpressionSquare ::= "[" ConstantExpression "]";
rules EnclosedExpressionSquare ::= "[" Expression "]";
rules MemberBitSelect ::= "." MemberIdentifier BitSelect;
rules MemberConstantBitSelect ::= "." MemberIdentifier ConstantBitSelect;

separator EnclosedExpressionSquare "";
separator MemberBitSelect "";
separator MemberConstantBitSelect "";
separator EnclosedConstantExpressionSquare "";


-- A.8.5 Expression left-side values (Done)
rules NetLvalue ::= 
PsOrHierarchicalNetIdentifier ConstantSelect 
| "{" [NetLvalue] "}"
| AssignmentPatternNetLvalue 
| AssignmentPatternExpressionType AssignmentPatternNetLvalue ;

rules VariableLvalue ::= 
HierarchicalVariableIdentifier Select
| PackageScope HierarchicalVariableIdentifier Select
| ImplicitClassHandle "." HierarchicalVariableIdentifier Select
| "{"[VariableLvalue] "}"
| AssignmentPatternVariableLvalue 
| AssignmentPatternExpressionType AssignmentPatternVariableLvalue 
| StreamingConcatenation;

rules NonrangeVariableLvalue ::= 
HierarchicalVariableIdentifier NonrangeSelect 
| ImplicitClassHandle "." HierarchicalVariableIdentifier NonrangeSelect 
| PackageScope HierarchicalVariableIdentifier NonrangeSelect;

separator nonempty NetLvalue ",";
separator nonempty VariableLvalue ",";

-- A.8.6 Operators (Done) 
rules UnaryOperator ::= "+" | "-" | "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~";
rules BinaryOperator ::= 
"+" | "-" | "*" | "/" | "%" | "==" | "!=" | "===" | "!==" | "==?" | "!=?" | "&&" | "||" | "**"
| "<" | "<=" | ">" | ">=" | "&" | "|" | "^" | "^~" | "~^" | ">>" | "<<" | ">>>" | "<<<"
| "->" | "<->"; 
rules IncOrDecOperator ::= "++" | "--";
rules UnaryModulePathOperator ::= "!" | "~" | "&" | "~&" | "|" | "~|" | "^" | "~^" | "^~";
rules BinaryModulePathOperator ::= "==" | "!=" | "&&" | "||" | "&" | "|" | "^" | "^~" | "~^";

-- A.8.7 Numbers (Done)
rules Number ::= 
IntegralNumber 
| RealNumber ;

rules IntegralNumber ::= 
DecimalNumber 
| OctalNumber 
| BinaryNumber 
| HexNumber ;

rules DecimalNumber ::= 
UnsignedNumber 
| MaybeSize DecimalBase UnsignedNumber 
| MaybeSize DecimalBase XDigit RepeatableUnderscore
| MaybeSize DecimalBase ZDigit RepeatableUnderscore;

rules BinaryNumber ::= MaybeSize BinaryBase BinaryValue ;
rules OctalNumber ::= MaybeSize OctalBase OctalValue ;
rules HexNumber ::= MaybeSize HexBase HexValue;

token Sign ('+' | '-');
rules Size ::= NonZeroUnsignedNumber ;
rules NonZeroUnsignedNumber ::= NonZeroDecimalDigit [MaybeUnderscoreOrDecimalDigit];

rules RealNumber ::= 
FixedPointNumber 
| UnsignedNumber Exp UnsignedNumber 
| UnsignedNumber Exp Sign UnsignedNumber 
| UnsignedNumber "." UnsignedNumber Exp UnsignedNumber 
| UnsignedNumber "." UnsignedNumber Exp Sign UnsignedNumber;

rules FixedPointNumber ::= UnsignedNumber "." UnsignedNumber;
token Exp ("e" | "E");

rules UnsignedNumber ::= DecimalDigit [ MaybeUnderscoreOrDecimalDigit];
rules BinaryValue ::= BinaryDigit [ MaybeUnderscoreOrBinaryDigit ];
rules OctalValue ::= OctalDigit [ MaybeUnderscoreOrOctalDigit ];
rules HexValue ::= HexDigit [ MaybeUnderscoreOrHexDigit ];

token DecimalBase (('\''["sS"] 'd') | ('\''["sS"] 'D'));
token BinaryBase (('\''["sS"] 'b') | ('\''["sS"] 'B'));
token OctalBase (('\''["sS"] 'o') | ('\''["sS"] 'O'));
token HexBase (('\''["sS"] 'h') | ('\''["sS"] 'H'));

token NonZeroDecimalDigit ('1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9');
token DecimalDigit ('0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9');
token BinaryDigit (XDigit | ZDigit | '0' | '1');
token OctalDigit (XDigit | ZDigit | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7');
token HexDigit (XDigit | ZDigit | '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F');
token XDigit ('x' | 'X');
token ZDigit ('z' | 'Z' | '?');

token UnbasedUnsizedLiteral ( {"'0"} | {"'1"} | '\''ZOrX);

rules MaybeSize ::= | Size;
rules MaybeUnderscoreOrDecimalDigit ::= "_" | DecimalDigit;
rules MaybeUnderscoreOrBinaryDigit ::= "_" | BinaryDigit;
rules MaybeUnderscoreOrOctalDigit ::= "_" | OctalDigit;
rules MaybeUnderscoreOrHexDigit ::= "_" | HexDigit;


rules RepeatableUnderscore ::= | "_" | "_" RepeatableUnderscore;

separator MaybeUnderscoreOrDecimalDigit "";
separator MaybeUnderscoreOrBinaryDigit "";

-- A.8.8 Strings
rule StringLiteral ::= "\"" String "\"";

-- A.9 General 
-- A.9.1 Attributes (Done)
rules AttributeInstance ::= "(*" [ AttrSpec ] "*)";
rules AttrSpec ::= AttrName | AttrName "=" ConstantExpression; 
rules AttrName ::= Ident ;

separator nonempty AttrSpec ",";

-- A.9.2 Comments

comment "//" ;
comment "/*" "*/" ;

-- A.9.3 Identifiers 
rules ArrayIdentifier ::= Ident ;
rules BlockIdentifier ::= Ident ;
rules BinIdentifier ::= Ident ;
rules CIdentifier ::= Ident;
rules CellIdentifier ::= Ident ;
rules CheckerIdentifier ::= Ident ;
rules ClassIdentifier ::= Ident ;
rules ClassVariableIdentifier ::= VariableIdentifier ;
rules ClockingIdentifier ::= Ident ;
rules ConfigIdentifier ::= Ident ;
rules ConstIdentifier ::= Ident ;
rules ConstraintIdentifier ::= Ident ;
rules CovergroupIdentifier ::= Ident ;
rules CovergroupVariableIdentifier ::= VariableIdentifier ;
rules CoverPointIdentifier ::= Ident ;
rules CrossIdentifier ::= Ident ;
rules DynamicArrayVariableIdentifier ::= VariableIdentifier ;
rules EnumIdentifier ::= Ident ;
-- EscapedIdentifier ::= "\\" {any_ASCII_character_except_white_space} WhiteSpace 
rules FormalIdentifier ::= Ident ;
rules FunctionIdentifier ::= Ident ;
rules GenerateBlockIdentifier ::= Ident ;
rules GenvarIdentifier ::= Ident ;
rules HierarchicalArrayIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalBlockIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalEventIdentifier ::= HierarchicalIdentifier ;

rules HierarchicalIdentifier ::= 
| [ HierarchicalScopePrefix ] Ident 
| "$root" "." [ HierarchicalScopePrefix ] Ident ;

separator HierarchicalScopePrefix "";

rules HierarchicalNetIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalParameterIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalPropertyIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalSequenceIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalTaskIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalTfIdentifier ::= HierarchicalIdentifier ;
rules HierarchicalVariableIdentifier ::= HierarchicalIdentifier ;
--Ident ::= SimpleIdentifier | EscapedIdentifier 
rules IndexVariableIdentifier ::= Ident ;
rules InterfaceIdentifier ::= Ident ;
rules InterfaceInstanceIdentifier ::= Ident ;
rules InoutPortIdentifier ::= Ident ;
rules InputPortIdentifier ::= Ident ;
rules InstanceIdentifier ::= Ident ;
rules LibraryIdentifier ::= Ident ;
rules MemberIdentifier ::= Ident ;
rules MethodIdentifier ::= Ident ;
rules ModportIdentifier ::= Ident ;
rules ModuleIdentifier ::= Ident ;
rules NetIdentifier ::= Ident ;
rules OutputPortIdentifier ::= Ident ;
rules PackageIdentifier ::= Ident ;
rules PackageScope ::= PackageIdentifier "::" | "$unit" "::";
rules ParameterIdentifier ::= Ident ;
rules PortIdentifier ::= Ident ;
rules ProductionIdentifier ::= Ident ;
rules ProgramIdentifier ::= Ident ;
rules PropertyIdentifier ::= Ident ;
rules PsClassIdentifier ::= MaybePackageScope ClassIdentifier ;
rules PsCovergroupIdentifier ::= MaybePackageScope CovergroupIdentifier ;
rules PsIdentifier ::= MaybePackageScope Ident ;

rules PsOrHierarchicalArrayIdentifier ::= 
HierarchicalArrayIdentifier 
| ImplicitClassHandle "." HierarchicalArrayIdentifier 
| ClassScope HierarchicalArrayIdentifier 
| PackageScope HierarchicalArrayIdentifier ;


rules PsOrHierarchicalNetIdentifier ::= MaybePackageScope NetIdentifier | HierarchicalNetIdentifier;
rules PsOrHierarchicalPropertyIdentifier ::= MaybePackageScope PropertyIdentifier | HierarchicalPropertyIdentifier ;
rules PsOrHierarchicalSequenceIdentifier ::= MaybePackageScope SequenceIdentifier | HierarchicalSequenceIdentifier ;
rules PsOrHierarchicalTfIdentifier ::= MaybePackageScope TfIdentifier | HierarchicalTfIdentifier ;

rules PsParameterIdentifier ::= 
ParameterIdentifier
| PackageScope ParameterIdentifier 
| ClassScope ParameterIdentifier 
| [ParameterScopePrefix] ParameterIdentifier;


rules PsTypeIdentifier ::= TypeIdentifier | PackageScope TypeIdentifier | "local::" TypeIdentifier;


rules SequenceIdentifier ::= Ident ;
rules SignalIdentifier ::= Ident ;
rules SimpleIdentifier ::= Ident ;
rules SpecparamIdentifier ::= Ident ;

token SystemTfIdentifier ('$'String); 

rules TaskIdentifier ::= Ident ;
rules TfIdentifier ::= Ident ;
rules TerminalIdentifier ::= Ident ;
rules TopModuleIdentifier ::= Ident ;
rules TypeIdentifier ::= Ident ;
rules UdpIdentifier ::= Ident ;
rules VariableIdentifier ::= Ident;

rules MaybePackageScope ::= | PackageScope;
rules MaybeEnclosedConstantExpressionSquare ::= | EnclosedConstantExpressionSquare;
rules ParameterScopePrefix ::= GenerateBlockIdentifier MaybeEnclosedConstantExpressionSquare ".";
rules HierarchicalScopePrefix ::= Ident ConstantBitSelect ".";

separator ParameterScopePrefix "";

-- A.9.4 White space 

-- Repeatables
separator LibraryDescription "" ;
separator nonempty FilePathSpec "," ;
separator Description "";
separator AttributeInstance "";
separator PackageImportDeclaration "";
separator PackageWithAttr "";
separator ParameterPortDeclarationComma "";
separator nonempty Port ",";
separator nonempty AttributeInstanceWithAnsiPortDeclaration ",";
separator nonempty PortReference ",";
separator nonempty BindTargetInstance ",";
separator LocalParameterDeclaration ";"
separator ConfigRuleStatement "";
separator LibCellCombinedIdentifier "";
separator InstanceIdentifierWithDot "";
separator LibraryIdentifier "";
separator nonempty NamedParameterAssignment ",";
separator nonempty CheckerPortItem ",";
separator VariableDimension "";
separator PropertyQualifier "";
separator ClassItemQualifier "";
separator MethodQualifier "";
separator ConstraintBlockItem "";
separator nonempty SolveBeforePrimary ",";
separator ConstraintExpression "";
separator nonempty DistItem ",";
separator nonempty Ident ",";
separator nonempty PackageImportItem ";";
separator nonempty StructUnionMember "";
separator nonempty EnumNameDeclaration ",";
separator PackedDimension "";
separator AnonymousProgramItem "";
separator ScopedClassIdentifiedMaybeParamValueAssignment "";
separator nonempty DefparamAssignment ",";
separator nonempty HierarchicalInstance ",";
separator nonempty HierarchicalIdentifier ",";